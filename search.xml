<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>递归与递推</title>
    <url>/2020/08/10/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h4 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选取任意多个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//达到n时输出</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不选当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state);</span><br><span class="line">	<span class="comment">//选择当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选出m个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，sum代表选取了多少个数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//当选不够m个的时候返回，剪枝处理</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n - u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//当选够m个的时候输出</span></span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			    <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前数字被选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//当前数字未选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h4><blockquote>
<p>把1~n这n个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果u等于n，则输出当前的排列</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : path) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对于当前第u位，将未选的数字填入，然后递归</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">			path.push_back(i + <span class="number">1</span>);</span><br><span class="line">			dfs(u + <span class="number">1</span>, state | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">			path.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h4><blockquote>
<p>你玩过拉灯游戏吗？25盏灯排成一个5x5的方形。每个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应；和这个灯上下左右相邻的灯也要相应地改变状态。<br>我们用数字“1”表示驿站开着的灯，用数字“0”表示关着的灯。下面这种状态<br>10111<br>01101<br>10111<br>10000<br>11011<br>在改变了最左上角的灯的状态后将变成：<br>01111<br>11101<br>10111<br>10000<br>11011<br>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步之内使所有的灯都变亮。</p>
</blockquote>
<p>我们可以知道对于一些要按的灯，按灯顺序不会影响最终灯的状态。那么我们可以把这个问题逐行分解，对于第一行我们将可能的按法全部枚举，对于后续行我们的目标就是使得前一行的灯全部按亮。由此判断可不可以在6次内全部按亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//g数组存放灯的状态，dx和dy用来表示邻近灯</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//turn函数会修改当前灯与周围灯的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">5</span> &amp;&amp; b &gt;=<span class="number">0</span> &amp;&amp; b &lt; <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="comment">//g[a][b] = '1' - g[a][b] + '0';</span></span><br><span class="line">			g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ans代表可能全亮的最少按灯次数</span></span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	<span class="comment">//遍历第一行可能的按法</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">1</span>&lt;&lt;<span class="number">5</span>; k++)&#123;</span><br><span class="line">		<span class="comment">//res代表按灯次数</span></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(k &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">				res++;</span><br><span class="line">				turn(<span class="number">0</span>, j);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//根据当前行出现的灭灯，修改下一行对应位置的灯</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">				<span class="keyword">if</span>(g[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">					res++;</span><br><span class="line">					turn(i + <span class="number">1</span>, j);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="comment">//观察最后一行灯是否全亮，如果全亮将按灯次数与之前比较</span></span><br><span class="line">		<span class="keyword">bool</span> is_successful = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(g[<span class="number">4</span>][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">				is_successful = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_successful) ans = min(ans, res);</span><br><span class="line">		<span class="built_in">memcpy</span>(g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">6</span>) ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; work() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h4><blockquote>
<p>汉诺塔问题，条件如下：</p>
</blockquote>
<ol>
<li>这里有A、B、C和D四座塔。</li>
<li>这里有n个圆盘，n的数量是恒定的， 且n&lt;=12。</li>
<li>每个圆盘的尺寸都不相同。</li>
<li>所有圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。</li>
<li>我们需要将所有的圆盘都从塔A转移到塔D上。</li>
<li>每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。<br>请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。<br><img src="https://img-blog.csdnimg.cn/20200809141024645.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>我们可以将其化为一个动态规划问题，对于三阶汉诺塔，我们可以将问题描述为D[n] = DD[n-1] x 2 + 1，即先将前n-1个圆盘移到第二个塔上，再将最后一个圆盘放到第三个塔上（仅一步操作），最后将第二个塔上的圆盘全部移动到第三个塔上。</p>
<p>而对于四阶汉诺塔，我们要寻找一个合适的圆盘i，将其上的圆盘先移动到一个塔上，所需移动次数设为F[i]。然后再将其下的圆盘移动到最后一个塔上，此时就是三阶汉诺塔问题，D[n-i]。然后再将前i个圆盘移动到最后塔上，即F[i]。这个合适的圆盘i就是使得移动次数最少的圆盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d[<span class="number">15</span>], f[<span class="number">15</span>];</span><br><span class="line">	d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">12</span>; i++)&#123;</span><br><span class="line">		d[i] = <span class="number">1</span> + d[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">			f[i] = min(f[i], f[j] * <span class="number">2</span> + d[i - j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++) <span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><blockquote>
<p>假设现在有两个自然数A和B，S是$A^B$的所有约数之和。<br>请你求出S mod 9901的值是多少。</p>
</blockquote>
<p>对于数A，我们可以将其分解成质数的形式，A=${p_{1}}^{k_{1}}{p_{2}}^{k_{2}}···{p_{n}}^{k_{n}}$，其中${p_{n}}$是A的质数约数，我们可以修改${k_{n}}$的大小来获得不同的约数，对于所有的约数之和我们可以表示为：<br>$({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}})\times ({p_{2}}^{0}+{p_{2}}^{1}+\cdot \cdot \cdot +{p_{2}}^{k_{2}})\times \cdot \cdot \cdot \times ({p_{n}}^{0}+{p_{n}}^{1}+\cdot \cdot \cdot +{p_{n}}^{k_{n}})$<br>对于每一部分，我们还可以进一步化简，例如，当$k_1$是奇数的时候，我们可以化简为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}}$<br>$= {p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2}+{p_{1}}^{k_{1}/2+1}\times ({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2})$<br>其中/代表着整数除法<br>如果$k_n$为偶数，那么就提出一个$p_n$即可，这样利用递归我们可以加速求解<br>而对于${p_{1}}^{k_{1}/2+1}$我们可以利用快速幂进行求解（参考上一博客位运算）。如下是代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//如果k是偶数就提出一个P，则k-1变为奇数</span></span><br><span class="line">	<span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (p % mod * sum(p, k - <span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="comment">//如果k是奇数</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> + qmi(p, k/<span class="number">2</span> + <span class="number">1</span>)) * sum(p, k/<span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A, B;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=A; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(A % i ==<span class="number">0</span>)&#123;</span><br><span class="line">			s++;</span><br><span class="line">			A /= i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s) res = res * sum(i, s * B) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!A) res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h4><blockquote>
<p>城市的规划在城市建设中是个大问题。<br>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。<br>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200810085620117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="city.png">当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。<br>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。<br>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。<br>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。</p>
</blockquote>
<p>我们可以发现每一等级的城市都是由上一等级城市旋转平移得到的，所以对于该题，我们可以将n等级的城市进行递归，从1等级开始处理。<br>将城市划分成四个区域，左上、右上、左下、右下四个分区，根据所在分区决定上一等级城市该如何旋转平移。然后再将得到的当前等级城市下的坐标，传递给下一等级的城市，直至规定等级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="function">PLL <span class="title">calc</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//边界结果</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//len代表当前等级下城市边长的一半（移动上一等级城市需要），cnt表示当前等级城市下街道数量的1/4（决定分区）</span></span><br><span class="line">    ll len=<span class="number">1L</span>L&lt;&lt;(n<span class="number">-1</span>),cnt=<span class="number">1L</span>L&lt;&lt;(<span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递归到最低级城市</span></span><br><span class="line">    PLL pos=calc(n<span class="number">-1</span>,m%cnt);</span><br><span class="line">    ll x=pos.first,y=pos.second;</span><br><span class="line">    <span class="comment">//z表示当前等级城市下，m序号的街道所处的分区，分为左上、右上、左下、右下四个分区，从而决定如何旋转</span></span><br><span class="line">    ll z=m/cnt;</span><br><span class="line">    <span class="comment">//根据分区位置旋转平移上一等级的街道，其中（x,y）代表上一等级城市下街道的位置</span></span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(y,x);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x,y+len);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x+len,y+len);</span><br><span class="line">    <span class="keyword">return</span> make_pair(<span class="number">2</span>*len<span class="number">-1</span>-y,len<span class="number">-1</span>-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n,a,b;</span><br><span class="line">        <span class="comment">//这里n代表当前城市等级，a、b代表两个街道的序号</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//简化边界处理，将序号从0开始</span></span><br><span class="line">        PLL x=calc(n,a<span class="number">-1</span>);</span><br><span class="line">        PLL y=calc(n,b<span class="number">-1</span>);</span><br><span class="line">        ll dx=x.first-y.first,dy=x.second-y.second;</span><br><span class="line">        <span class="keyword">double</span> ans=(<span class="built_in">sqrt</span>(dx*dx+dy*dy)*<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归改递推"><a href="#递归改递推" class="headerlink" title="递归改递推"></a>递归改递推</h4><p>用递推来实现递归代码，需要借助STL中的栈，计算机本身在处理递归代码的时候也是使用栈来实现的。</p>
<p>在这里我们通过“递归实现组合型枚举”来举例说明，我们首先要把原递归代码划分位置，用来标记处理过程。通过定义结构体，作为栈的保存对象，其中要包含标记位置。主函数中我们循环取出栈首元素，根据所标记的位置来决定如何处理当前元素，直至栈空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos, u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n _ u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.yop;</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.pos == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">					<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			t.pos = <span class="number">1</span>;</span><br><span class="line">			stk.push(t);</span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t.pos == <span class="number">1</span>)&#123;</span><br><span class="line">			t.pos = <span class="number">2</span>;<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(t);<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//可去掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记位置的方法只是个通用模板，我们可以将得到的递推继续优化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">				<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        stk.push(&#123;t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		stk.push(&#123;t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2020/08/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="C-位运算基本知识"><a href="#C-位运算基本知识" class="headerlink" title="C++位运算基本知识"></a>C++位运算基本知识</h1><h2 id="与"><a href="#与" class="headerlink" title="与"></a>与</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a与b表示</span></span><br><span class="line">a &amp; b</span><br></pre></td></tr></table></figure>

<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a或b表示</span></span><br><span class="line">a | b</span><br></pre></td></tr></table></figure>

<h2 id="非"><a href="#非" class="headerlink" title="非"></a>非</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a非表示</span></span><br><span class="line">!a</span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a异或b表示</span></span><br><span class="line">a ^ b</span><br></pre></td></tr></table></figure>
<p>通过异或可以实现很多功能，例如模拟加法计算，快速找寻配偶等等。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的提出的初衷就是希望计算机在运算的时候只使用加法<br>正数的补码和原码相同<br>负数的补码是取反码（符号位不变）以后再加1</p>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>11111110</td>
</tr>
<tr>
<td>10000001</td>
<td>01111110</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a的按位取反</span></span><br><span class="line">~a</span><br></pre></td></tr></table></figure>
<p>通过按位取反，我们可以实现lowbit功能，即找寻某一数字，最低位的1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如输入10010100，可以返回00000100，即最低位1表示的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (~num + <span class="number">1</span>) &amp; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左移、右移"><a href="#左移、右移" class="headerlink" title="左移、右移"></a>左移、右移</h2><p>左移n位相当于，原数乘上2的n次方<br>右移n位相当于，原数除以2的n次方<br>移位又分为算术移位和逻辑移位，C++和Python都是算数移位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ a左移n位</span></span><br><span class="line">a &lt;&lt; n;</span><br><span class="line"><span class="comment">//C++ a右移n位</span></span><br><span class="line">a &gt;&gt; n;</span><br></pre></td></tr></table></figure>

<h1 id="位运算例题"><a href="#位运算例题" class="headerlink" title="位运算例题"></a>位运算例题</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote>
<p>题目1：求a的b次方对p取模的值</p>
</blockquote>
<p>首先我们会想到直接使用cmath头文件的pow函数可以很快求解。但pow函数在运算会返回double类型，如果输入数据过大就会溢出。<br>如果利用循环求解，每个循环中再求模，效率又太低。因此我们可以使用快速幂来加速我们的代码执行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = res * <span class="number">1l</span>l * a % p;</span><br><span class="line">		a = a * <span class="number">1l</span>l * a % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目2：求a乘b对p取模的值</p>
</blockquote>
<p>类比上题求解方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ULL a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	ULL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = (res + a) % p;</span><br><span class="line">		a = a * <span class="number">2</span> % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h2><blockquote>
<p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。</p>
</blockquote>
<p>旅行商问题，是NP完全问题，目前还不能在多项式时间内求解，我们能做的就是优化暴力求解，本方法采用了状态压缩动态规划的方法加速计算。<br>我们定义一个状态用来表示哪些点我们已经到达，哪些点我们还没有访问到，用state来表示。<br>例如，state=001011，表示第0，1，3点已经访问。<br>我们设一个函数 f[state][j] ，表示当前走到 j 点的路径长度，我们的目标是求解 f[0111…1][n-1] ，并使其最短，采用动态规划可以表示成下式：<br>f[state][j] = min(f[state][j]，f[state_j][k] + weight[k][j]）<br>其中state_j代表着state将j点置0，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[M][N], weight[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; weight[i][j];</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">					<span class="keyword">if</span>(i-(<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j]=min(f[i][j], f[i-(<span class="number">1</span>&lt;&lt;j)][k] + weight[k][j]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) <span class="number">-1</span>][n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2020/07/14/test/</url>
    <content><![CDATA[<p>我是一个测试文件。</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS_Tutorials</title>
    <url>/2020/07/25/ROS-Tutorials/</url>
    <content><![CDATA[<p>本科时候图方便仅仅使用了Windows下的V-REP（想想用gazebo还要学Linux和ROS就好麻烦…)，最近由于需要学习了ROS，也算是填上本科时候埋下的坑(&gt;﹏&lt;)。</p>
<p>本文主要针对<a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">ROS wiki教程</a>基于ROS Noetic踩得雷做一下总结，关于如何学习ROS，可以参考知乎高赞,马学长的回答<a href="https://zhuanlan.zhihu.com/p/26007106" target="_blank" rel="noopener">ROS学习入门（抛砖引玉篇）</a>。</p>
<h2 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h2><p>目前有在维护的版本有Kinetic、Melodic以及Noetic。由于我的Ubuntu版本是20.04，所以选择了Noetic，并且Noetic是最新版本，会维护到2025年。</p>
<p>在安装Ubuntu系统的时候切记主分区要大于15G，我最开始分了10G结果ROS安一半，它满了！！！弄得我又重装了一遍系统…</p>
<h2 id="节点、话题、服务"><a href="#节点、话题、服务" class="headerlink" title="节点、话题、服务"></a>节点、话题、服务</h2><p>这部分按照教程来做就可以了，注意Hydro版本和非Hydro版本的命令区别。</p>
<h2 id="创建ROS消息和服务"><a href="#创建ROS消息和服务" class="headerlink" title="创建ROS消息和服务"></a>创建ROS消息和服务</h2><p>在新增ROS消息和服务以后我们要对Catkin_package.txt进行修改，增加依赖，生成器，调用生成。</p>
<p>因为好多部分教程都要求找到注释代码，修改以后去掉注释，使代码生效。例如下面这样：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/%E6%8D%95%E8%8E%B7.PNG" alt=""></p>
<p>我又…是图方便，没有查找注释代码，直接将修改代码添加到尾部，当时觉得反正那部分也是注释无效的，结果又开启了找BUG之旅…</p>
<p>最后发现CMakeList.txt文件必须遵循如下的格式，不然就无法正确地编译：<br>1.查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package()<br>2.添加消息/服务/操作文件：add_message_files()…<br>3.调用消息/服务/操作生成：generate_messages()</p>
<h2 id="roswtf使用"><a href="#roswtf使用" class="headerlink" title="roswtf使用"></a>roswtf使用</h2><p>roswtf 可以检查你的ROS系统并尝试发现问题。</p>
<p>当我运行roswtf时发现系统报错,需要更新rosdep。<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-00-15%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>而当我按照提示运行命令rosdep update时又会发现：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-01-04%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>卑微的我又按照提示安装了python3-rosdep2<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-20%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>本以为按照提示将缺少的软件包安装以后就万事大吉，结果当运行roscore的时候原本正常的ROS开始报错！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-03-30%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>于是我就经历了卸ROS，安ROS，Google+Baidu无限的月读轮回当中╥﹏╥<br>最后偶然发现，在安装rosdep的过程当中，第一行提示正在卸载ros-noetic-desktop-full，what！！！？？？原来是rosdep在安装的过程中偷偷摸摸把我的ros-noetic卸载了，于是我在安装rosdep以后重装了一遍ros，这时候在运行roscore、roswtf就没问题啦！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-57%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-39%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-59%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
</search>
