<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2020/07/14/test/</url>
    <content><![CDATA[<p>我是一个测试文件。</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS_Tutorials</title>
    <url>/2020/07/25/ROS-Tutorials/</url>
    <content><![CDATA[<p>本科时候图方便仅仅使用了Windows下的V-REP（想想用gazebo还要学Linux和ROS就好麻烦…)，最近由于需要学习了ROS，也算是填上本科时候埋下的坑(&gt;﹏&lt;)。</p>
<p>本文主要针对<a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">ROS wiki教程</a>基于ROS Noetic踩得雷做一下总结，关于如何学习ROS，可以参考知乎高赞,马学长的回答<a href="https://zhuanlan.zhihu.com/p/26007106" target="_blank" rel="noopener">ROS学习入门（抛砖引玉篇）</a>。</p>
<h2 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h2><p>目前有在维护的版本有Kinetic、Melodic以及Noetic。由于我的Ubuntu版本是20.04，所以选择了Noetic，并且Noetic是最新版本，会维护到2025年。</p>
<p>在安装Ubuntu系统的时候切记主分区要大于15G，我最开始分了10G结果ROS安一半，它满了！！！弄得我又重装了一遍系统…</p>
<h2 id="节点、话题、服务"><a href="#节点、话题、服务" class="headerlink" title="节点、话题、服务"></a>节点、话题、服务</h2><p>这部分按照教程来做就可以了，注意Hydro版本和非Hydro版本的命令区别。</p>
<h2 id="创建ROS消息和服务"><a href="#创建ROS消息和服务" class="headerlink" title="创建ROS消息和服务"></a>创建ROS消息和服务</h2><p>在新增ROS消息和服务以后我们要对Catkin_package.txt进行修改，增加依赖，生成器，调用生成。</p>
<p>因为好多部分教程都要求找到注释代码，修改以后去掉注释，使代码生效。例如下面这样：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/%E6%8D%95%E8%8E%B7.PNG" alt=""></p>
<p>我又…是图方便，没有查找注释代码，直接将修改代码添加到尾部，当时觉得反正那部分也是注释无效的，结果又开启了找BUG之旅…</p>
<p>最后发现CMakeList.txt文件必须遵循如下的格式，不然就无法正确地编译：<br>1.查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package()<br>2.添加消息/服务/操作文件：add_message_files()…<br>3.调用消息/服务/操作生成：generate_messages()</p>
<h2 id="roswtf使用"><a href="#roswtf使用" class="headerlink" title="roswtf使用"></a>roswtf使用</h2><p>roswtf 可以检查你的ROS系统并尝试发现问题。</p>
<p>当我运行roswtf时发现系统报错,需要更新rosdep。<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-00-15%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>而当我按照提示运行命令rosdep update时又会发现：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-01-04%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>卑微的我又按照提示安装了python3-rosdep2<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-20%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>本以为按照提示将缺少的软件包安装以后就万事大吉，结果当运行roscore的时候原本正常的ROS开始报错！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-03-30%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>于是我就经历了卸ROS，安ROS，Google+Baidu无限的月读轮回当中╥﹏╥<br>最后偶然发现，在安装rosdep的过程当中，第一行提示正在卸载ros-noetic-desktop-full，what！！！？？？原来是rosdep在安装的过程中偷偷摸摸把我的ros-noetic卸载了，于是我在安装rosdep以后重装了一遍ros，这时候在运行roscore、roswtf就没问题啦！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-57%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-39%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-59%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2020/08/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="C-位运算基本知识"><a href="#C-位运算基本知识" class="headerlink" title="C++位运算基本知识"></a>C++位运算基本知识</h1><h2 id="与"><a href="#与" class="headerlink" title="与"></a>与</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a与b表示</span></span><br><span class="line">a &amp; b</span><br></pre></td></tr></table></figure>

<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a或b表示</span></span><br><span class="line">a | b</span><br></pre></td></tr></table></figure>

<h2 id="非"><a href="#非" class="headerlink" title="非"></a>非</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a非表示</span></span><br><span class="line">!a</span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a异或b表示</span></span><br><span class="line">a ^ b</span><br></pre></td></tr></table></figure>
<p>通过异或可以实现很多功能，例如模拟加法计算，快速找寻配偶等等。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的提出的初衷就是希望计算机在运算的时候只使用加法<br>正数的补码和原码相同<br>负数的补码是取反码（符号位不变）以后再加1</p>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>11111110</td>
</tr>
<tr>
<td>10000001</td>
<td>01111110</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a的按位取反</span></span><br><span class="line">~a</span><br></pre></td></tr></table></figure>
<p>通过按位取反，我们可以实现lowbit功能，即找寻某一数字，最低位的1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如输入10010100，可以返回00000100，即最低位1表示的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (~num + <span class="number">1</span>) &amp; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左移、右移"><a href="#左移、右移" class="headerlink" title="左移、右移"></a>左移、右移</h2><p>左移n位相当于，原数乘上2的n次方<br>右移n位相当于，原数除以2的n次方<br>移位又分为算术移位和逻辑移位，C++和Python都是算数移位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ a左移n位</span></span><br><span class="line">a &lt;&lt; n;</span><br><span class="line"><span class="comment">//C++ a右移n位</span></span><br><span class="line">a &gt;&gt; n;</span><br></pre></td></tr></table></figure>

<h1 id="位运算例题"><a href="#位运算例题" class="headerlink" title="位运算例题"></a>位运算例题</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote>
<p>题目1：求a的b次方对p取模的值</p>
</blockquote>
<p>首先我们会想到直接使用cmath头文件的pow函数可以很快求解。但pow函数在运算会返回double类型，如果输入数据过大就会溢出。<br>如果利用循环求解，每个循环中再求模，效率又太低。因此我们可以使用快速幂来加速我们的代码执行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = res * <span class="number">1l</span>l * a % p;</span><br><span class="line">		a = a * <span class="number">1l</span>l * a % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目2：求a乘b对p取模的值</p>
</blockquote>
<p>类比上题求解方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ULL a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	ULL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = (res + a) % p;</span><br><span class="line">		a = a * <span class="number">2</span> % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h2><blockquote>
<p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。</p>
</blockquote>
<p>旅行商问题，是NP完全问题，目前还不能在多项式时间内求解，我们能做的就是优化暴力求解，本方法采用了状态压缩动态规划的方法加速计算。<br>我们定义一个状态用来表示哪些点我们已经到达，哪些点我们还没有访问到，用state来表示。<br>例如，state=001011，表示第0，1，3点已经访问。<br>我们设一个函数 f[state][j] ，表示当前走到 j 点的路径长度，我们的目标是求解 f[0111…1][n-1] ，并使其最短，采用动态规划可以表示成下式：<br>f[state][j] = min(f[state][j]，f[state_j][k] + weight[k][j]）<br>其中state_j代表着state将j点置0，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[M][N], weight[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; weight[i][j];</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">					<span class="keyword">if</span>(i-(<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j]=min(f[i][j], f[i-(<span class="number">1</span>&lt;&lt;j)][k] + weight[k][j]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) <span class="number">-1</span>][n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>基本算法小结</title>
    <url>/2020/09/10/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="飞行员兄弟"><a href="#飞行员兄弟" class="headerlink" title="飞行员兄弟"></a>飞行员兄弟</h4><blockquote>
<p>“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有16个把手的冰箱。<br>已知每个把手可以处于以下两种状态之一：打开或关闭。<br>只有当所有把手都打开时，冰箱才会打开。<br>把手可以表示为一个4х4的矩阵，您可以改变任何一个位置[i,j]上把手的状态。<br>但是，这也会使得第i行和第j列上的所有把手的状态也随着改变。<br>请你求出打开冰箱所需的切换把手的次数最小值是多少。</p>
</blockquote>
<p>可以参考<a href="https://blog.csdn.net/weixin_41676930/article/details/107890536" target="_blank" rel="noopener">递推与递归</a>中”费解的开关”以及<a href="https://blog.csdn.net/weixin_41676930/article/details/107751475" target="_blank" rel="noopener">位运算</a>异或的知识。我们把所有可能的情况枚举，将二维矩阵压缩成一维，利用异或更改开关状态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c用来装载输入，state是将输入转化成一维‘0’‘1’数据，check是state的备份，用来核验操作，ans是当前操作次数，answer是最少操作次数</span></span><br><span class="line"><span class="comment">//res是最优操作步骤，temp是当前操作步骤</span></span><br><span class="line"><span class="built_in">string</span> c[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> state=<span class="number">0</span>, check, ans, answer = INT_MAX;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res, temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get函数用来将一维的某位转化成二维的行列，并输出操作当前开关位置应该异或的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row, col, num = <span class="number">0</span>;</span><br><span class="line">    row = index / <span class="number">4</span>;</span><br><span class="line">    col = index % <span class="number">4</span>;</span><br><span class="line">    temp.push_back(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(row+<span class="number">1</span>, col+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        num += <span class="number">1</span> &lt;&lt; row * <span class="number">4</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != row) num += <span class="number">1</span> &lt;&lt; col + <span class="number">4</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">	<span class="comment">//压缩成一维</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(c[i][j] == <span class="string">'+'</span>) state += <span class="number">1</span> &lt;&lt; (i*<span class="number">4</span> + j);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//枚举所有可能的操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>); i++)&#123;</span><br><span class="line">        ans = <span class="number">0</span>, check = state;</span><br><span class="line">        temp.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>, index=<span class="number">0</span>; j&lt;=i; index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;i)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = get(index);</span><br><span class="line">                check = check ^ num;<span class="comment">//异或1，可以更改开关状态</span></span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            j &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最终开关全部打开，比较当前操作数与之前的结果</span></span><br><span class="line">        <span class="keyword">if</span>(check == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans &lt; answer)&#123;</span><br><span class="line">                answer = ans;</span><br><span class="line">                res = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; answer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++) <span class="built_in">cout</span> &lt;&lt; res[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; res[i].second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="占卜DIY"><a href="#占卜DIY" class="headerlink" title="占卜DIY"></a>占卜DIY</h4><blockquote>
<p>达达学会了使用扑克DIY占卜。<br>方法如下：<br>一副去掉大小王的扑克共52张，打乱后均分为13堆，编号1~13，每堆4张，其中第13堆称作“生命牌”，也就是说你有4条命。<br>这里边，4张K被称作死神。<br>初始状态下，所有的牌背面朝上扣下。<br>流程如下：<br>1.抽取生命牌中的最上面一张(第一张)。<br>2.把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。(例如抽到2，正面朝上放到第2堆牌最上面，又比如抽到J，放到第11堆牌最上边，注意是正面朝上放)<br>3.从刚放了牌的那一堆最底下(最后一张)抽取一张牌，重复第2步。（例如你上次抽了2，放到了第二堆顶部，现在抽第二堆最后一张发现是8，又放到第8堆顶部………）<br>4.在抽牌过程中如果抽到K，则称死了一条命，就扔掉K再从第1步开始。<br>5.当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现4张正面朝上的牌(比如4个A)，则称“开了一对”，当然4个K是不算的。<br>6.统计一共开了多少对，开了0对称作”极凶”，1~2对为“大凶”，3对为“凶”，4~5对为“小凶”，6对为“中庸”，7~8对“小吉”，9对为“吉”，10~11为“大吉”，12为“满堂开花，极吉”。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">14</span>][<span class="number">4</span>], b[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//处理输入</span></span><br><span class="line">    <span class="keyword">char</span> input;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">13</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">4</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; input;</span><br><span class="line">            <span class="keyword">if</span>(input == <span class="string">'0'</span>) a[i][j] = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">'A'</span>) a[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input &lt;= <span class="string">'9'</span>) a[i][j] = input - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">'J'</span>) a[i][j] = <span class="number">11</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(input == <span class="string">'Q'</span>) a[i][j] = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i][j] = <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//k代表K被抽到几次，res是最终有几对，num是当前牌的数字，temp是备份</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, res = <span class="number">0</span>, num, temp;</span><br><span class="line">    <span class="comment">//如果K抽到4次结束</span></span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">4</span>)&#123;</span><br><span class="line">    	<span class="comment">//其实num就是最后一堆牌</span></span><br><span class="line">        num = a[<span class="number">13</span>][k];</span><br><span class="line">        <span class="comment">//如果num不是K就循环放牌取牌的操作</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">13</span>)&#123;</span><br><span class="line">        	<span class="comment">//b数组是记录这个数字的牌抽到了几次</span></span><br><span class="line">            b[num]++;</span><br><span class="line">            <span class="comment">//对于已经抽出来的牌，数值置为-1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[num][i] != <span class="number">-1</span>)&#123;</span><br><span class="line">                    temp = a[num][i];</span><br><span class="line">                    a[num][i] = <span class="number">-1</span>;</span><br><span class="line">                    num = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束说明抽到了K</span></span><br><span class="line">        k ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算有几对</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">14</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(b[i] == <span class="number">4</span>) res++;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h4><blockquote>
<p>分形，具有以非整数维形式充填空间的形态特征。<br>通常被定义为“一个粗糙或零碎的几何形状，可以分成数个部分，且每一部分都（至少近似地）是整体缩小后的形状”，即具有自相似的性质。<br>现在，定义“盒子分形”如下：<br>一级盒子分形：<br>   <img src="https://img-blog.csdnimg.cn/20200831180045390.png#pic_center" alt="X"><br>二级盒子分形：<br>   <img src="https://img-blog.csdnimg.cn/20200831180018979.png#pic_center" alt="X  X
     X
   X  X"><br>如果用B(n - 1)代表第n-1级盒子分形，那么第n级盒子分形即为：<br><img src="https://img-blog.csdnimg.cn/20200831180120865.png#pic_center" alt="在这里插入图片描述"><br>  你的任务是绘制一个n级的盒子分形。</p>
</blockquote>
<p>类比<a href="https://blog.csdn.net/weixin_41676930/article/details/107890536" target="_blank" rel="noopener">递推与递归</a>中分形之城的做法，采用递归，对上一级结果进行平移，在返回给下一级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> res[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">core</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        res[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">'X'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    core(n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//len是代表上一级图形的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//对上一级返回的结果进行平移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len; j++)&#123;</span><br><span class="line">            res[i + <span class="number">2</span> * len][j] = res[i][j];</span><br><span class="line">            res[i + len][j + len] = res[i][j];</span><br><span class="line">            res[i][j + <span class="number">2</span> * len] = res[i][j];</span><br><span class="line">            res[i + <span class="number">2</span> * len][j + <span class="number">2</span> * len] = res[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n代表输入级别</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">    	<span class="comment">//n为-1结束</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> core(n);</span><br><span class="line">        <span class="comment">//len是图形长度</span></span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=len; j++)&#123;</span><br><span class="line">            	<span class="comment">//'\0'是字符数组的默认值</span></span><br><span class="line">                <span class="keyword">if</span>(res[i][j] == <span class="string">'\0'</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'-'</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="袭击"><a href="#袭击" class="headerlink" title="袭击"></a>袭击</h4><blockquote>
<p>在与联盟的战斗中屡战屡败后，帝国撤退到了最后一个据点。<br>依靠其强大的防御系统，帝国击退了联盟的六波猛烈进攻。<br>经过几天的苦思冥想，联盟将军亚瑟终于注意到帝国防御系统唯一的弱点就是能源供应。<br>该系统由N个核电站供应能源，其中任何一个被摧毁都会使防御系统失效。<br>将军派出了N个特工进入据点之中，打算对能源站展开一次突袭。<br>不幸的是，由于受到了帝国空军的袭击，他们未能降落在预期位置。<br>作为一名经验丰富的将军，亚瑟很快意识到他需要重新安排突袭计划。<br>他现在最想知道的事情就是哪个特工距离其中任意一个发电站的距离最短。<br>你能帮他算出来这最短的距离是多少吗？</p>
</blockquote>
<p>采用分治的方法，按照x坐标排序，均分成两部分，分别计算两部分的距离最小值，记为d。对于两部分的最小值我们只需要考虑分界线两侧+d和-d范围内的点即可，因为距离分界线远的点必然会超出当前的距离最小值。然后对范围内的点按照y方向排序，根据鸽巢原理我们可以证明遍历每个点的时候最多只需要考虑6个点即可，并且y方向排序可以采用归并排序，因此最终时间复杂度是$O(nlogn)$。表示成下图<br><img src="https://img-blog.csdnimg.cn/20200901101312407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>灰虚线表示将当前排序的点均分，灰实线表示距离分界线d的范围，d是两部分距离的最小值，在合并的时候只需考虑灰实线范围内的点的距离即可，只有这部分内的点距离可能会小于d。对于灰实线范围内的点，按照y轴排好序后，遍历每个点身边的常数个点，更新距离最小值并返回，对于每个点最多只需考虑周围的6个点，我们可以利用鸽巢原理表示成下图。<br><img src="https://img-blog.csdnimg.cn/20200901102521571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>对于一个点，我们只需考虑以其为圆心，半径为d的半圆内的点，只有该范围的点到圆心的距离才可能小于d，如上图蓝色半圆所示，当我们遍历到红色的点的时候只需考虑该半圆内的点。为了方便求解，把半圆简化成矩形，将矩形分割成6个小部分，我们可以证明该矩形范围内不会超过6个点，因为每个小矩形的对角线的长度小于d，因此若矩形内落入7个以上的点，必有2点落入同一小矩形，那么两点的距离小于d，就不满足d是最小距离的前提条件，所以每一层递归遍历最多是$O(6n)$，6是常数项，可以省去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//储存每一个点的信息，包括x，y，type表示是核电站还是特工，重载比较符，方便排序。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> info &amp;i) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; i.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;point[<span class="number">200010</span>], temp[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两个点的距离，若是同一阵营（type）就返回无穷，否则计算欧式距离</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(info i, info j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i.type == j.type) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">double</span> dx = i.x - j.x, dy = i.y - j.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="comment">//边界条件，mid是中值，mid_x存储中线x坐标，递归两部分，返回距离最小值res</span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> mid_x = point[mid].x;</span><br><span class="line">    <span class="keyword">double</span> res = min(dfs(l, mid), dfs(mid+<span class="number">1</span>, r));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归并排序，排序y值</span></span><br><span class="line">    <span class="keyword">int</span> f = l, b = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f &gt; mid || b &lt;= r &amp;&amp; point[f].y &gt; point[b].y) temp[i] = point[b++];</span><br><span class="line">        <span class="keyword">else</span> temp[i] = point[f++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++) point[i] = temp[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//统计处于正负d范围内的点。</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(point[i].x &lt;= mid_x + res &amp;&amp; point[i].x &gt;= mid_x - res)</span><br><span class="line">            temp[index++] = point[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历范围内的点，更新res</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span> &amp;&amp; temp[j].y + res &gt;= temp[i].y; j--)</span><br><span class="line">            res = min(res, dis(temp[j], temp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//t表示测试集数量，n是特工和核电站的数量</span></span><br><span class="line">    <span class="keyword">int</span> t, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; point[i].x &gt;&gt; point[i].y;</span><br><span class="line">            point[i].type = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&lt;n*<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; point[i].x &gt;&gt; point[i].y;</span><br><span class="line">            point[i].type = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        sort(point, point+<span class="number">2</span>*n);</span><br><span class="line">       	</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2</span>*n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> res = dfs(l, r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3f\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="防线"><a href="#防线" class="headerlink" title="防线"></a>防线</h4><blockquote>
<p>达达学习数学竞赛的时候受尽了同仁们的鄙视，终于有一天……受尽屈辱的达达黑化成为了黑暗英雄怪兽达达。<br>就如同中二漫画的情节一样，怪兽达达打算毁掉这个世界。<br>数学竞赛界的精英 lqr 打算阻止怪兽达达的阴谋，于是她集合了一支由数学竞赛选手组成的超级行动队。<br>由于队员们个个都智商超群，很快，行动队便来到了怪兽达达的黑暗城堡的下方。<br>但是，同样强大的怪兽达达在城堡周围布置了一条“不可越过”的坚固防线。<br>防线由很多防具组成，这些防具分成了 N 组。<br>我们可以认为防线是一维的，那么每一组防具都分布在防线的某一段上，并且同一组防具是等距离排列的。<br>也就是说，我们可以用三个整数 S， E 和 D 来描述一组防具，即这一组防具布置在防线的 S，S + D，S + 2D，…，S + KD(K∈ Z，S + KD≤E，S + (K + 1)D&gt;E)位置上。<br>黑化的怪兽达达设计的防线极其精良。如果防线的某个位置有偶数个防具，那么这个位置就是毫无破绽的(包括这个位置一个防具也没有的情况，因为 0 也是偶数)。<br>只有有奇数个防具的位置有破绽，但是整条防线上也最多只有一个位置有奇数个防具。<br>作为行动队的队长，lqr 要找到防线的破绽以策划下一步的行动。<br>但是，由于防具的数量太多，她实在是不能看出哪里有破绽。作为 lqr 可以信任的学弟学妹们，你们要帮助她解决这个问题。</p>
</blockquote>
<p>暴力的算法是将所有输入填入一个数组，但这样的时间复杂度太高，最多能达到$O(len^{n})$，len是数组长度。<br>题干中“整条防线上也最多只有一个位置有奇数个防具”，提醒我们可以利用前缀和的思想，当某一个位置之前所有的防具总数是奇数，说明奇数防具的位置在该位置之前。因此可以采用二分查找，以前缀和条件来判断，因此总的时间复杂度是$O(nlogn)$。对于每种防具在某一位置之前的数量可以用$(min(pos, E) - S)/d + 1$来表示。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//t是测试集数量，n是防具种数</span></span><br><span class="line"><span class="keyword">int</span> t, n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储防具信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, e, d;</span><br><span class="line">&#125;defence[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算防具个数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(mid &gt;= defence[i].s) sum += (min(mid, defence[i].e) - defence[i].s) / defence[i].d + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; defence[i].s &gt;&gt; defence[i].e &gt;&gt; defence[i].d;</span><br><span class="line">            len = max(defence[i].e, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len, mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid) % <span class="number">2</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r != len) <span class="built_in">cout</span> &lt;&lt; r &lt;&lt; <span class="string">" "</span> &lt;&lt; check(r) - check(r<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"There's no weakness."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="赶牛入圈"><a href="#赶牛入圈" class="headerlink" title="赶牛入圈"></a>赶牛入圈</h4><blockquote>
<p>农夫约翰希望为他的奶牛们建立一个畜栏。<br>这些挑剔的畜生要求畜栏必须是正方形的，而且至少要包含C单位的三叶草，来当做它们的下午茶。<br>畜栏的边缘必须与X，Y轴平行。<br>约翰的土地里一共包含N单位的三叶草，每单位三叶草位于一个1 x 1的土地区域内，区域位置由其左下角坐标表示，并且区域左下角的X,Y坐标都为整数，范围在1到10000以内。<br>多个单位的三叶草可能会位于同一个1 x 1的区域内，因为这个原因，在接下来的输入中，同一个区域坐标可能出现多次。<br>只有一个区域完全位于修好的畜栏之中，才认为这个区域内的三叶草在畜栏之中。<br>请你帮约翰计算一下，能包含至少C单位面积三叶草的情况下，畜栏的最小边长是多少。</p>
</blockquote>
<p>因为输入坐标范围太大，我们可以先将其离散化。利用前缀和可以快速求解某个正方形内草的数量。但是朴素的算法复杂度有$O(n^{4})$，为了降低时间，可以采用二分的方法。对于正方形的边长查找，用前缀和作为判定条件，可以将时间复杂度降低到$O(n^{2}logn)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//grass表示草坪前缀和，c是草的最低数量，n是输入坐标数，axis存储输入坐标，trans是离散化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> grass[N][N], c, n;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; axis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; trans;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断当前正方形长度是否满足条件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;trans.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a &lt; i &amp;&amp; trans[i] - trans[a + <span class="number">1</span>] + <span class="number">1</span> &gt; len) a++;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;trans.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(b &lt; j &amp;&amp; trans[j] - trans[b + <span class="number">1</span>] + <span class="number">1</span> &gt; len) b++;</span><br><span class="line">            num = grass[i][j] + grass[a][b] - grass[a][j] - grass[i][b];</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= c) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分找到离散化后的坐标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = trans.size() - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(trans[mid] &gt;= num) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//max_len存储最大长度 </span></span><br><span class="line">    <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; n;</span><br><span class="line">    trans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; axis[i].first &gt;&gt; axis[i].second;</span><br><span class="line">        trans.push_back(axis[i].first);</span><br><span class="line">        trans.push_back(axis[i].second);</span><br><span class="line">        max_len = max(axis[i].first &gt; axis[i].second? axis[i].first: axis[i].second, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    sort(trans.begin(), trans.end());</span><br><span class="line">    trans.erase(unique(trans.begin(), trans.end()), trans.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) grass[get(axis[i].first)][get(axis[i].second)]++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求解前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;trans.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;trans.size(); j++)</span><br><span class="line">            grass[i][j] = grass[i<span class="number">-1</span>][j] + grass[i][j<span class="number">-1</span>] - grass[i<span class="number">-1</span>][j<span class="number">-1</span>] + grass[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//二分查找边长</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = max_len, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="糖果传递"><a href="#糖果传递" class="headerlink" title="糖果传递"></a>糖果传递</h4><blockquote>
<p>有n个小朋友坐成一圈，每人有a[i]个糖果。<br>每人只能给左右两人传递糖果。<br>每人每次传递一个糖果代价为1。<br>求使所有人获得均等糖果的最小代价。</p>
</blockquote>
<p>类比<a href="https://blog.csdn.net/weixin_41676930/article/details/108192972" target="_blank" rel="noopener">贪心算法</a>中的均分纸牌问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> child[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n是孩子个数，num是糖果数量</span></span><br><span class="line">    <span class="keyword">int</span> n, num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">//形成前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        child[i] = num + child[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求出均值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg = child[n] / n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) child[i] -= i * avg;</span><br><span class="line">    </span><br><span class="line">    sort(child + <span class="number">1</span>, child + n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中位数问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum += <span class="built_in">abs</span>(child[n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>] - child[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="士兵"><a href="#士兵" class="headerlink" title="士兵"></a>士兵</h4><blockquote>
<p>格格兰郡的N名士兵随机散落在全郡各地。<br>格格兰郡中的位置由一对(x,y)整数坐标表示。<br>士兵可以进行移动，每次移动，一名士兵可以向上，向下，向左或向右移动一个单位（因此，他的x或y坐标也将加1或减1）。<br>现在希望通过移动士兵，使得所有士兵彼此相邻的处于同一条水平线内，即所有士兵的y坐标相同并且x坐标相邻。<br>请你计算满足要求的情况下，所有士兵的总移动次数最少是多少。<br>需注意，两个或多个士兵不能占据同一个位置。</p>
</blockquote>
<p>类比<a href="https://blog.csdn.net/weixin_41676930/article/details/108096153" target="_blank" rel="noopener">排序算法</a>的中位数问题。我们可以将x和y分开求解，y直接找到中位数即可，而x我们要转化一下，先将x排序，然后假设我们要排列的起始位置是a，那么目标位置就变成$a,a+1,a+2,···,a+n$，于是我们要求解的最下值问题变成：<br>$$x_{i} - a - i + 1$$<br>令$x’<em>{i} = x</em>{i} - i + 1$, 则转变成<br>$$x’_{i} - a $$<br>便可利用中位数方法求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x[<span class="number">10010</span>], y[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n是士兵数量</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(x+<span class="number">1</span>, x+n+<span class="number">1</span>);</span><br><span class="line">    sort(y+<span class="number">1</span>, y+n+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算y的中位数，以及对x处理</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(y[n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>] - y[i]);</span><br><span class="line">        x[i] -= i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(x+<span class="number">1</span>, x+n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算x的中位数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(x[n + <span class="number">1</span> &gt;&gt; <span class="number">1</span>] - x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数的进制转换"><a href="#数的进制转换" class="headerlink" title="数的进制转换"></a>数的进制转换</h4><blockquote>
<p>编写一个程序，可以实现将一个数字由一个进制转换为另一个进制。<br>这里有62个不同数位{0-9,A-Z,a-z}。</p>
</blockquote>
<p>可以先转换成10进制，再转换成要求进制。<br>也可以直接利用input进制，除以output进制，得到的余数就是最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, input, output;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num, res, temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将输入字符串转换成数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    res.clear();</span><br><span class="line">    num.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) num.push_back(c - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) num.push_back(c - <span class="string">'A'</span> + <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> num.push_back(c - <span class="string">'a'</span> + <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度除法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num.size())&#123;</span><br><span class="line">        <span class="keyword">bool</span> start = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        temp.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.size(); i++)&#123;</span><br><span class="line">            flag = num[i] + flag * input;</span><br><span class="line">            <span class="keyword">if</span>(flag / output)&#123;</span><br><span class="line">                temp.push_back(flag / output);</span><br><span class="line">                flag %= output;    </span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(start) temp.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num = temp;</span><br><span class="line">        res.insert(res.begin(), flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> number : res)&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt;= <span class="number">0</span> &amp;&amp; number &lt;= <span class="number">9</span>) <span class="built_in">cout</span> &lt;&lt; number;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number &gt;= <span class="number">10</span> &amp;&amp; number &lt;= <span class="number">35</span>) <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'A'</span> + number - <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>)(<span class="string">'a'</span> + number - <span class="number">36</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; input &gt;&gt; output;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        trans();</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; input &lt;&lt; <span class="string">" "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; output &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        out();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h4><blockquote>
<p>农民约翰的N头奶牛（编号为1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。<br>奶牛们不是非常有创意，只提出了一个杂技表演：<br>叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。<br>奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。<br>这N头奶牛中的每一头都有着自己的重量Wi以及自己的强壮程度Si。<br>一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。<br>您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。</p>
</blockquote>
<p>类比<a href="https://blog.csdn.net/weixin_41676930/article/details/108192972" target="_blank" rel="noopener">贪心算法</a>中的国王游戏，该题最终导出依据$W_{i} + S_{i}$排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cow[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, w, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; s;</span><br><span class="line">        cow[i].first = w + s;</span><br><span class="line">        cow[i].second = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort(cow, cow+n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, res = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        res = max(res, sum - cow[i].second);</span><br><span class="line">        sum += cow[i].first - cow[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大的和"><a href="#最大的和" class="headerlink" title="最大的和"></a>最大的和</h4><blockquote>
<p>给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。<br>矩形的总和是该矩形中所有元素的总和。<br>在这个问题中，具有最大和的子矩形被称为最大子矩形。</p>
</blockquote>
<p>我们先考虑对于给定的一个数列，如何求出其最大连续子数列的和。可以采用动态规划的思想，遍历数列并累加和，当该和值小于0的时候我们就舍弃，重新累加，因为如果之前数列的和值小于0，会拉低后续数列的值。<br>$$dp[i] = max(dp[i-1], 0) + num[i]$$<br>那么对于二维数组，我们可以通过前缀和的方式加速求解，同时限定$x_{min}$和$x_{max}$，在某些行内遍历所有列，这样可以使得算法复杂度从$O(n^{4})$降低到$O(n^{3})$。表示成下图。<br><img src="https://img-blog.csdnimg.cn/20200902103447693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>遍历所有可能的$x_{min}$和$x_{max}$，限定浅灰色的范围。在该范围内对于某一列的和，即阴影部分的和，可以采用前缀和快速求解，即蓝色减去绿色。再配合动态规划求解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n表示边长，num是二维数组</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nums[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//形成前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            nums[i][j] += nums[i<span class="number">-1</span>][j];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//限定行，遍历列</span></span><br><span class="line">    <span class="keyword">int</span> res = INT_MIN, sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=n; k++)&#123;</span><br><span class="line">                sum += nums[i][k] - nums[j][k];</span><br><span class="line">                res = max(res, sum);</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><blockquote>
<p>今天某公司有M个任务需要完成。<br>每个任务都有相应的难度级别和完成任务所需时间。<br>第i个任务的难度级别为yi，完成任务所需时间为xi分钟。<br>如果公司完成此任务，他们将获得（500 * xi + 2 * yi）美元收入。<br>该公司有N台机器，每台机器都有最长工作时间和级别。<br>如果任务所需时间超过机器的最长工作时间，则机器无法完成此任务。<br>如果任务难度级别超过机器的级别，则机器无法完成次任务。<br>每台机器一天内只能完成一项任务。<br>每个任务只能由一台机器完成。<br>请为他们设计一个任务分配方案，使得该公司能够最大化他们今天可以完成的任务数量。<br>如果有多种解决方案，他们希望选取赚取利润最高的那种。</p>
</blockquote>
<p>对于每个任务获得的收入，x的占比要大于y，因此我们应当优先完成x大的任务，可以将x从大到小遍历，对于每个任务，选取符合条件的最小的y，可以参考<a href="https://blog.csdn.net/weixin_41676930/article/details/108192972" target="_blank" rel="noopener">贪心算法</a>中的防晒。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mch[<span class="number">100010</span>], task[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n代表机器数量，m代表任务数量</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span> &gt;&gt; mch[i].first &gt;&gt; mch[i].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) <span class="built_in">cin</span> &gt;&gt; task[i].first &gt;&gt; task[i].second;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//按照先x后y的顺序排序</span></span><br><span class="line">    sort(mch, mch+n);</span><br><span class="line">    sort(task, task+m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, index = n<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//存储满足大于x的集合，再利用lower_bound二分查找符合y的最小值</span></span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(mch[index].first &gt;= task[i].first) s.insert(mch[index--].second);</span><br><span class="line">        <span class="keyword">auto</span> iter = s.lower_bound(task[i].second);</span><br><span class="line">        <span class="keyword">if</span>(iter != s.end())&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            res += task[i].first * <span class="number">500</span> + task[i].second * <span class="number">2</span>;</span><br><span class="line">            s.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="string">" "</span> &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构，算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h4><blockquote>
<p>莫斯科正在举办一个大型国际会议，有n个来自不同国家的科学家参会。<br>每个科学家都只懂得一种语言。<br>为了方便起见，我们把世界上的所有语言用1到109之间的整数编号。<br>在会议结束后，所有的科学家决定一起去看场电影放松一下。<br>他们去的电影院里一共有m部电影正在上映，每部电影的语音和字幕都采用不同的语言。<br>对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。<br>现在科学家们决定大家看同一场电影。<br>请你帮忙选择一部电影，可以让观影很开心的人最多。<br>如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。</p>
</blockquote>
<p>根据题意，我们可以先把科学家的语言统计成哈希表，再根据每个电影的语音和字幕统计听得懂和看得懂的人数，将每个电影保存成一个结构体，对这若干个结构体进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a和b记录电影听得懂和看得懂的人数，c记录电影的序号，最终我们要输出电影序号。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; ans[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//m代表电影数，n代表科学家数量，index作为哈希表语言key。</span></span><br><span class="line"><span class="keyword">int</span> m, n, index;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num, sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.a==b.a) <span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">    <span class="keyword">return</span> a.a &gt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//统计科学家的语言，形成哈希表sum</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        sum[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录每部电影听得懂和看得懂的人数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        ans[i].a=sum[index];</span><br><span class="line">        ans[i].c=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        ans[i].b=sum[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对结构体进行排序</span></span><br><span class="line">    sort(ans, ans+m, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出排序后的首元素，+1是因为我们从0开始记录的，需要处理边界</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>].c + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h4><blockquote>
<p>在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。<br>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。<br>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p>
</blockquote>
<p>我们假设把货仓建在N家商店的中位数位置可以使得每家商店到货仓的距离之和最小，即货仓两侧的商店数量应一样多。如果不一样多，当货仓向中位数移动的时候，就会存在商店多的一侧距离之和减少，商店少的一侧距离之和增加，总体就会减小，因此可知，将货仓建在中位数是合理的。<br><img src="https://img-blog.csdnimg.cn/20200819121022697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//记录n家商店的位置，形成数组</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选取中位数，记录距离总和</span></span><br><span class="line">    <span class="keyword">int</span> mid = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(a[i]-a[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态中位数：依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。</p>
</blockquote>
<p>该题我们可以维护两个堆，分别是大顶堆和小顶堆，其中大顶堆的堆顶就是我们当前的中位数，对于新输入的数，我们采取如下步骤</p>
<ol>
<li>加上新元素，当前序列总数是偶数，那么与大顶堆堆顶比较，<br>  (1)如果大于大顶堆堆顶，那么插入到小顶堆中<br>  (2)如果小于大顶堆堆顶，那么取出大顶堆堆顶放入到小顶堆中，将新元素放入大顶堆。</li>
<li>加上新元素，当前序列总数是奇数，那么与小顶堆堆顶比较，<br> (1)如果小于小顶堆堆顶，那么插入到大顶堆中<br> (2)如果大于小顶堆堆顶，那么取出小顶堆堆顶放入到大顶堆中，将新元素放入小顶堆中。      </li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//结果中位数数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="comment">//small小顶堆，big大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; big;</span><br><span class="line"> 	<span class="comment">//判断奇偶，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(j % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!big.size() || m &lt; small.top()) big.push(m);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big.push(small.top());</span><br><span class="line">                small.pop();</span><br><span class="line">                small.push(m);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(big.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt; big.top())&#123;</span><br><span class="line">                small.push(big.top());</span><br><span class="line">                big.pop();</span><br><span class="line">                big.push(m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> small.push(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n表示输入组数，index是编号，num是序列长度</span></span><br><span class="line">    <span class="keyword">int</span> n, index, num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index &gt;&gt; num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = solve(num);</span><br><span class="line">        <span class="comment">//输出编号，以及中位数个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="string">" "</span> &lt;&lt; (num + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//输出中位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=res.size(); j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[j<span class="number">-1</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(j % <span class="number">10</span>) || j==res.size()) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="均分纸牌问题"><a href="#均分纸牌问题" class="headerlink" title="均分纸牌问题"></a>均分纸牌问题</h4><blockquote>
<p>n个人坐成一排，手里总共有m张牌，现在每次操作可以使得相邻两人之间传递一张牌，问至少需要多少次操作可以使得n个人手里的纸牌数相同。</p>
</blockquote>
<p>我们可以从边界开始考虑，如果当前排在第一位的人手里牌数a1少于m/n，那么他必将从第二个人手中抽取a1-m/n张牌，使得自己手里的牌数达到均值。这时，我们只需考虑a2~an需要多少次操作才能使所有人手里的纸牌数相同，因此该题可以转化为贪心问题。<br>注：若第一位人的手里牌数多于m/n，那么他必将多余的牌传递给第二个人才能达到要求。若在计算过程中某人手里的牌数是负数也没有关系，这说明他和之前所有人手里的牌数是不够均分到m/n的，在实际过程中，我们会先分给他足够的牌数，传递给之前的人。<br>所以这道题就变成里求解$Sum = \sum_{i=1}^{n}|S_{i}|$，其中$S_{i}=\sum_{j=1}^{i}(A_{j}-m/n)$，表示第i点需要和下一点传递的纸牌数</p>
<blockquote>
<p>现在我们将难度提升一下，若这n个人做成一圈，那么问至少需要多少次操作可以使得n个人手里的纸牌数相同。</p>
</blockquote>
<p>首先，给出一个结论，对于最少操作次数必然会有两人之间没有纸牌传递。<br>该结论的证明，我…不会…，以下给出个人简陋不严谨的思路。<br>对于该图我们可以简化成相邻两点，实线代表他们之间的传递，虚线代表其余点的传递流总和，蓝色代表纸牌走向。<br><img src="https://img-blog.csdnimg.cn/20200820093704920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因此我们可以将问题分成两种情况考虑，对于左边的情况，必然可以去掉一个相邻点之间的纸牌传递，使得纸牌传递不会存在循环流，减少传递次数。<br>而对于右边的情况，可以知道，右边红点手里的牌数是少于平均值的，那么我们可以让离其最近的一段连续区域（纸牌平均数多于总的平均数）来多给它传递，然后去掉离该点远的传递流，这样可以减少总的传递次数。（以后有更好的证明再来补……)</p>
<p>至此，我们可以将环形纸牌问题转化成普通纸牌问题，只需考虑在哪里将环形剪断，所得到的传递次数最少。我们假设，要在k和k+1之间将环剪断，那么，对于每个点所需的传递次数，表示如下：<br>$$k+1: S_{k+1}-S_{k}$$$$k+2: S_{k+2}-S_{k}$$</p>
<center> ~ </center>

<p>$$n: S_{n}-S_{k}$$$$1: S_{1}-S_{k}+S_{n}$$</p>
<center> ~ </center>

<p>$$k: S_{k}-S_{k}+S_{n}$$</p>
<p>其中$S_{i}$和均分纸牌相同，$S_{n}=0$，所以公式可以简化成求解使总和最小的k，即$argmin_{k}\sum S_{i}-S_{k}$。至此，我们就可以将问题转化为货仓选址问题，求出中位数，就是最优解，我们来看一个例题。</p>
<blockquote>
<p>七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。<br>于是TYVJ今年举办了一次线下七夕祭。<br>Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。<br>TYVJ七夕祭和11区的夏祭的形式很像。<br>矩形的祭典会场由N排M列共计N×M个摊点组成。<br>虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。<br>Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。<br>不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。<br>两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。<br>由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。<br>现在Vani想知道他的两个要求最多能满足多少个。<br>在此前提下，至少需要交换多少次摊点。</p>
</blockquote>
<p>因为只能横纵交换，所以列交换不会影响最终行内感兴趣的摊点数，我们可以把问题拆分成两个环形均分纸牌问题，分别求解行列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大横纵摊位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> u=<span class="number">100010</span>; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[u],c[u],f[u];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,t,i,j,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[u],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//形成S, 见均分纸牌公式</span></span><br><span class="line">        a[i]-=a[<span class="number">0</span>]/n;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对S排序，选取中位数，求出结果</span></span><br><span class="line">    sort(f+<span class="number">1</span>,f+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) ans+=<span class="built_in">abs</span>(f[i]-f[n+<span class="number">1</span>&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//n表示行数，m表示列数，t代表测试组数</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="comment">//对于每个感兴趣的摊位在行列处+1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        b[x]++,c[y]++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首位表示感兴趣摊位数总和</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) b[<span class="number">0</span>]+=b[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) c[<span class="number">0</span>]+=c[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断感兴趣摊位数是否可以均分到行、列</span></span><br><span class="line">    <span class="keyword">if</span>(b[<span class="number">0</span>]%n==<span class="number">0</span>&amp;&amp;c[<span class="number">0</span>]%m==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"both %lld\n"</span>,calc(b,n)+calc(c,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">0</span>]%n==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"row %lld\n"</span>,calc(b,n));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>]%m==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"column %lld\n"</span>,calc(c,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><blockquote>
<p>在这个问题中，您必须分析特定的排序算法—-超快速排序。<br>该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。<br>对于输入序列9 1 0 5 4，超快速排序生成输出0 1 4 5 9。<br>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p>
</blockquote>
<p>该问题就是需要计算序列中有多少对逆序对，我们要把所有逆序对全部交换，所以问题也可以改成冒泡排序需要多少次操作。<br>对于计算逆序对，常用的方法就是归并排序，朴素算法需要$O(n)$复杂度，而采用归并，可以降低为$O(nlogn)$。我们的关键就在于在归并的时候，采用双指针计算逆序对。如果前面指针所指的数要大于后面指针的数，这就说明前面序列的剩余元素都要大于后面指针所指元素，通过这种方式确定序列中的逆序对。用图来表示：<br><img src="https://img-blog.csdnimg.cn/20200820112350266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为逆序对数有可能多余10的10次幂，我们定义成long long类型</span></span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; nums, ll l, ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge(nums, l, mid);</span><br><span class="line">    merge(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fp是前面指针，从l开始，bp是后面指针，从mid+1开始</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; temp;</span><br><span class="line">    ll fp = l, bp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bp &gt; r || fp &lt;= mid &amp;&amp; nums[fp] &lt; nums[bp]) temp.push_back(nums[fp++]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="comment">//如果nums[fp]&gt;nums[bp]，我们要统计一下前面指针剩余元素个数</span></span><br><span class="line">            res += mid + <span class="number">1</span> - min(mid + <span class="number">1</span>, fp);</span><br><span class="line">            temp.push_back(nums[bp++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l; i&lt;=r; i++) nums[i] = temp[index++];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; nums;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	<span class="comment">//输入序列</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//n表示序列长度，当n为0则结束输入</span></span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你一定玩过八数码游戏，它实际上是在一个3×3的网格中进行的,1个空格和1至8这8个数字恰好不重不漏地分布在这3×3的网格中。<br>例如：<br>5 2 8<br>1 3 _<br>4 6 7<br>在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>例如在上例中，空格可与左、上、下面的数字交换，分别变成：<br>左：<br>5 2 8<br>1 _ 3<br>4 6 7<br>上：<br>5 2 _<br>1 3 8<br>4 6 7<br>下：<br>5 2 8<br>1 3 7<br>4 6 _<br>奇数码游戏是它的一个扩展，在一个n×n的网格中进行，其中n为奇数，1个空格和1至$n^{2}−1$这$n^{2}−1$个数恰好不重不漏地分布在n×n的网格中。<br>空格移动的规则与八数码游戏相同，实际上，八数码就是一个n=3的奇数码游戏。<br>现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。</p>
</blockquote>
<p>对于二维数组我们通常将其转化成一维数组，如同环我们通常转化成链<br>可以发现，当”_“在同一行内移动的时候不会改变整个数组的逆序对个数。<br>而当”_“在列内交换的时候会改变整个数组的逆序对个数。而该题的n为奇数，可以得出列交换并不会改变数组中逆序对个数的奇偶性。<br>因此可以说逆序对个数奇偶性不同的奇数码不能相互转换。而对于奇偶性相同的奇数码则可以相互转换（怎么证明我也不知道，知道了再来补上吧……)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//res记录逆序对个数，nums1记录第一个网格，nums2记录第二个网格，temp是临时数组</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="keyword">int</span> nums1[<span class="number">250010</span>], nums2[<span class="number">250010</span>], temp[<span class="number">250010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 同上题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge(nums, l, mid);</span><br><span class="line">    merge(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fp = l, bp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fp &gt; mid || bp &lt;= r &amp;&amp; nums[fp] &gt; nums[bp])&#123;</span><br><span class="line">            res += mid + <span class="number">1</span> - fp;</span><br><span class="line">            temp[i] = nums[bp++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> temp[i] = nums[fp++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++) nums[i]=temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//输入数据0表示下划线，我们将输入数据保存成一维数组</span></span><br><span class="line">    <span class="keyword">int</span> num, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != n*n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(!num) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> nums1[i++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != n*n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(!num) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> nums2[i++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分别计算逆序对个数</span></span><br><span class="line">    merge(nums1, <span class="number">0</span>, n*n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = res;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    merge(nums2, <span class="number">0</span>, n*n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//返回两个数组逆序对个数奇偶性是否相同</span></span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">2</span> == ans%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(solve(n)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2020/09/14/%E6%A0%88/</url>
    <content><![CDATA[<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><blockquote>
<p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈。<br>push(x)–将元素x插入栈中<br>pop()–移除栈顶元素<br>top()–得到栈顶元素<br>getMin()–得到栈中最小元素</p>
</blockquote>
<p>利用一个辅助栈维护最小元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s, temp;</span><br><span class="line">    <span class="keyword">int</span> min_x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.size()) min_x = x;</span><br><span class="line">        <span class="keyword">else</span> min_x = temp.top();</span><br><span class="line">        s.push(x);</span><br><span class="line">        temp.push(min(x, min_x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.pop();</span><br><span class="line">        temp.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temp.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><blockquote>
<p>你将要实现一个功能强大的整数序列编辑器。<br>在开始时，序列是空的。<br>编辑器共有五种指令，如下：<br>1、“I x”，在光标处插入数值x。<br>2、“D”，将光标前面的第一个元素删除，如果前面没有元素，则忽略此操作。<br>3、“L”，将光标向左移动，跳过一个元素，如果左边没有元素，则忽略此操作。<br>4、“R”，将光标向右移动，跳过一个元素，如果右边没有元素，则忽略次操作。<br>5、“Q k”，假设此刻光标之前的序列为a1,a2,…,an,输出$_{1\leqslant i\leqslant k}^{max}$Si，其中Si=a1+a2+…+ai。</p>
</blockquote>
<p>将光标前后分成两部分，利用两个栈来维护，其中前面的栈栈顶元素是光标前面的元素，后面的栈栈顶元素是光标后面的元素。光标每次的移动就是两个栈分别的弹出和压入，删除就是前面栈的弹出，插入就是前面栈的弹出。而前缀和最大值只在光标右移和插入是更新前缀和，并于此前的最大值比较。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//front光标前的栈，back光标后的栈，sum前缀和</span></span><br><span class="line"><span class="keyword">int</span> front[<span class="number">1000010</span>], back[<span class="number">1000010</span>], sum[<span class="number">1000010</span>];</span><br><span class="line"><span class="comment">//l，r分别指向栈顶元素</span></span><br><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n表示命令数，s表示当前前缀和总和</span></span><br><span class="line">    sum[<span class="number">0</span>] = INT_MIN;</span><br><span class="line">    <span class="keyword">int</span> n, num, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="comment">//插入操作，更新前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'I'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            front[l++] = num;</span><br><span class="line">            s += num;</span><br><span class="line">            sum[l] = max(sum[l<span class="number">-1</span>], s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l != <span class="number">0</span>)&#123;</span><br><span class="line">                s -= front[--l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左移操作，前面栈的栈顶元素给到后面栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l != <span class="number">0</span>)&#123;</span><br><span class="line">                back[r++] = front[--l];</span><br><span class="line">                s -= front[l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右移操作，右边栈的栈顶元素给到左边栈，同时更新前缀和</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'R'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(r != <span class="number">0</span>)&#123;</span><br><span class="line">                front[l++] = back[--r];</span><br><span class="line">                s += front[l<span class="number">-1</span>];</span><br><span class="line">                sum[l] = max(sum[l<span class="number">-1</span>], s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取前缀和</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; sum[num] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="火车进站"><a href="#火车进站" class="headerlink" title="火车进站"></a>火车进站</h4><blockquote>
<p>这里有n列火车将要进站再出站，但是，每列火车只有1节，那就是车头。<br>这n列火车按1到n的顺序从东方左转进站，这个车站是南北方向的，它虽然无限长，只可惜是一个死胡同，而且站台只有一条股道，火车只能倒着从西方出去，而且每列火车必须进站，先进后出。<br>也就是说这个火车站其实就相当于一个栈，每次可以让右侧头火车进栈，或者让栈顶火车出站。<br>车站示意如图：</p>
</blockquote>
<blockquote>
<pre><code>出站&lt;——    &lt;——进站
         |车|
         |站|
         |__|</code></pre></blockquote>
<blockquote>
<p>现在请你按《字典序》输出前20种可能的出栈方案。</p>
</blockquote>
<p>我们可以将火车进站分成两个过程，一个是入栈，一个是出栈，因此可以用递归遍历所有的可能，因为要按照字典序输出，所以深度优先搜索要优先递归出栈过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in表示站内的火车，out表示出站的火车</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; in;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line"><span class="keyword">int</span> n, cnt = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="comment">//当输出达到20个或者火车全部出站，返回，结束查找</span></span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(out.size() == n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;out.size(); i++) <span class="built_in">cout</span> &lt;&lt; out[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出站</span></span><br><span class="line">    <span class="keyword">if</span>(in.size())&#123;</span><br><span class="line">        out.push_back(in.top());</span><br><span class="line">        in.pop();</span><br><span class="line">        dfs(num);</span><br><span class="line">        in.push(out.back());</span><br><span class="line">        out.pop_back();  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入站</span></span><br><span class="line">    <span class="keyword">if</span>(num &lt;= n)&#123;</span><br><span class="line">        in.push(num++);</span><br><span class="line">        dfs(num--);</span><br><span class="line">        in.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="火车进出站问题"><a href="#火车进出站问题" class="headerlink" title="火车进出站问题"></a>火车进出站问题</h4><blockquote>
<p>一列火车n节车厢，依次编号为1,2,3,…,n。<br>每节车厢有两种运动方式，进栈与出栈，问n节车厢出栈的可能排列方式有多少种。</p>
</blockquote>
<p>将火车进站看作“+”，将火车出站看作“-”，那么对于某个进出站过程可以用加减号来表示，例如序列1、2、3、4，出栈成3、4、2、1，那么可以表示成“+++-+—”。则排列方式可以间接由加减号的排序映射，对于“+”、“-”的排序限制条件就是在任意位置之前，“+”的总数一定要多于“-”的总数，这样才能保证不会要求空栈弹出。如果把“+”看作横轴，“-”看作纵轴，可以表示成如下图。</p>
<p><img src="https://img-blog.csdnimg.cn/20200908152302418.png#pic_center" alt="在这里插入图片描述"><br>绿色的点代表我们要到达的点，对于一个“++-++-++–+—”可以表示成蓝色的线。<br><img src="https://img-blog.csdnimg.cn/2020090815254630.png#pic_center" alt="在这里插入图片描述"><br>而对于上图红色的线，是“+++—-++++—”，是不能满足任意位置“+”总数多于“-”总数的要求，因此我们的序列不能穿过黄色的线。<br><img src="https://img-blog.csdnimg.cn/20200908153439829.png#pic_center" alt="在这里插入图片描述"><br>而对于任意穿过黄色的路径，必将到达上图的红线，对于一个非法路径，我们总可以找到关于红线对称的路径到达(n,n+1)点，即紫色的点，因此对于非法路径数就是$\binom{2n}{n-1}$，到达绿色点的可能路径数是$\binom{2n}{n}$，因此合法路径数就是$\binom{2n}{n}-\binom{2n}{n-1}=\frac{1}{n+1}\binom{2n}{n}$。<br>因为该题数据较大，因此采用高精度乘法，为了加快运算，我们将每个数分解质因子乘积的形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flag是标志位，用来筛出质因子，primes中存放所有小于2n的质因子，mi存放每个质因子的次数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120010</span>;</span><br><span class="line"><span class="keyword">int</span> n, cnt, flag[N], primes[N], mi[N];</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找质因子，对于找到的质因子，我们将其倍数置位，不再访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_primes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;<span class="number">2</span>*n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;<span class="number">2</span>*n; j+=i)&#123;</span><br><span class="line">                flag[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到num阶乘中质因子prime的次数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> prime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num / prime)&#123;</span><br><span class="line">        ans += num / prime;</span><br><span class="line">        num /= prime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> prime)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=res.size() - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            t += res[i] * prime;</span><br><span class="line">            res[i] = t % <span class="number">1000000000</span>;</span><br><span class="line">            t /= <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(t!=<span class="number">0</span>)&#123;</span><br><span class="line">            res.insert(res.begin(), t % <span class="number">1000000000</span>);</span><br><span class="line">            t /= <span class="number">1000000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    get_primes();</span><br><span class="line">    <span class="keyword">int</span> den = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)&#123;</span><br><span class="line">    	<span class="comment">//分别求出2n和n的质因子次数，并相减表示除法</span></span><br><span class="line">        mi[primes[i]] = get(<span class="number">2</span> * n, primes[i]) - <span class="number">2</span> * get(n, primes[i]);</span><br><span class="line">        <span class="comment">//减去n+1中质因子的次数</span></span><br><span class="line">        <span class="keyword">while</span>(den % primes[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            mi[primes[i]]--;</span><br><span class="line">            den /= primes[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//高精度累乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">        <span class="keyword">if</span>(mi[primes[i]]) multi(mi[primes[i]], primes[i]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;res.size(); i++) <span class="built_in">printf</span>(<span class="string">"%09d"</span>, res[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="直方图中最大的矩形"><a href="#直方图中最大的矩形" class="headerlink" title="直方图中最大的矩形"></a>直方图中最大的矩形</h4><blockquote>
<p>直方图是由在公共基线处对齐的一系列矩形组成的多边形。<br>矩形具有相等的宽度，但可以具有不同的高度。<br>例如，图例左侧显示了由高度为2,1,4,5,1,3,3的矩形组成的直方图，矩形的宽度都为1：<br><img src="https://img-blog.csdnimg.cn/20200908190712565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>通常，直方图用于表示离散分布，例如，文本中字符的频率。<br>现在，请你计算在公共基线处对齐的直方图中最大矩形的面积。<br>图例右图显示了所描绘直方图的最大对齐矩形。</p>
</blockquote>
<p>我们可以遍历矩形，找到该矩形高度下的左边界和右边界，即可求出该高度下面积的最大值。对于边界的求解可以利用栈，对于栈顶矩形的高度大于当前矩形的高度，我们就将栈顶矩形弹出，直至找到第一个小于当前矩形高度的矩形，以此作为左边界，并将当前举行压入栈中，使得栈内矩形高度始终是递增趋势，对于右边界同理。通过栈便可以在$O(n)$时间内求出答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">//stack是要维护的栈，存放矩阵的索引</span></span><br><span class="line"><span class="keyword">int</span> n, <span class="built_in">stack</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个矩阵的信息，包括高度、左边界和右边界</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matix</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> height, l, r;</span><br><span class="line">&#125;num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//边界条件</span></span><br><span class="line">    num[<span class="number">0</span>].height = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//n表示每组矩阵个数，当n为0则结束</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n, n)&#123;</span><br><span class="line">   		<span class="comment">//输入矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; num[i].height;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//id是指向栈顶元素</span></span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        	<span class="comment">//找到第一个小于当前矩阵高度的栈顶</span></span><br><span class="line">            <span class="keyword">while</span>(num[i].height &lt;= num[<span class="built_in">stack</span>[id]].height)&#123;</span><br><span class="line">                id--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录左边界</span></span><br><span class="line">            num[i].l = <span class="built_in">stack</span>[id];</span><br><span class="line">            <span class="comment">//将当前矩阵压栈</span></span><br><span class="line">            <span class="built_in">stack</span>[++id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//逆序找右边界，同上</span></span><br><span class="line">        id = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(num[i].height &lt;= num[<span class="built_in">stack</span>[id]].height)&#123;</span><br><span class="line">                id--;</span><br><span class="line">            &#125;</span><br><span class="line">            num[i].r = <span class="built_in">stack</span>[id]? <span class="built_in">stack</span>[id]<span class="number">-1</span>: n-<span class="built_in">stack</span>[id];</span><br><span class="line">            <span class="built_in">stack</span>[++id] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历查找最大矩形面积</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>, area;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            area = num[i].height * <span class="number">1l</span>l * (num[i].r - num[i]. l);</span><br><span class="line">            res = max(res, area);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/08/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="二分查找算法模板"><a href="#二分查找算法模板" class="headerlink" title="二分查找算法模板"></a>二分查找算法模板</h4><p>二分模板有两种，适用于不同情况。</p>
<h5 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h5><p>当区间[l, r]的更新操作是r=mid；l=mid+1时，计算mid不需要加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当区间[l, r]的更新操作是r = mid - 1; l = mid时，计算mid时需加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_real</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line">	<span class="comment">//也可以改成循环次数for (int k = 0; k &lt; 100; k++）</span></span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (check()) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h5><p>我们将要求解的问题设成一个求解曲线极值的问题。我们每次将$l$和$r$进行三等分，得到mid_l和mid_r，比较mid_l和mid_r得到三种情况：</p>
<ol>
<li>f(mid_l)&gt;f(mid_r)  r=mid_r</li>
<li>f(mid_l)&lt;f(mid_r)  l=mid_l</li>
<li>f(mid_l)=f(mid_r) 且mid_l=mid_r，则得解 , 否则归为以上两类均可</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200814092307705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsearch</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> mid_l, mid_r, eps=<span class="number">1e-6</span>;</span><br><span class="line">	<span class="keyword">while</span>(r - l &lt; eps)&#123;</span><br><span class="line">		mid_l = l + (l - r) / <span class="number">3</span>;</span><br><span class="line">		mid_r = l + <span class="number">2</span> * (l - r) / <span class="number">3</span></span><br><span class="line">		<span class="keyword">if</span> (fun(mid_l) &gt; fun(mid_r)) r=mid_r;</span><br><span class="line">		<span class="keyword">else</span> l=mid_l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们这个曲线一定要是单调的，否则三分法就无效。</p>
<h4 id="二分查找例题"><a href="#二分查找例题" class="headerlink" title="二分查找例题"></a>二分查找例题</h4><blockquote>
<p>农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。<br>约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。<br>围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。<br>在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。</p>
</blockquote>
<p>考虑二分查找平均值最大的牛的数量。对于判定条件，我们可以利用之前学过的<a href="https://blog.csdn.net/weixin_41676930/article/details/107971905" target="_blank" rel="noopener">前缀和</a>来辅助判定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cows[N];</span><br><span class="line"><span class="keyword">double</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> avg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="number">-1</span>] + cows[i] - avg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断第j和前缀和是否大于第j-m的前缀和，大于则成立，否则不成立</span></span><br><span class="line">    <span class="keyword">double</span> minv = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m; j &lt;= n; i++, j++)&#123;</span><br><span class="line">    	<span class="comment">//minv用来存储距离第j-m个数以前的最小值</span></span><br><span class="line">        minv = min(minv, sum[i]);</span><br><span class="line">        <span class="keyword">if</span> (sum[j] &gt;= minv) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n代表总的田地数，m代表至少包含的田地数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; cows[i];</span><br><span class="line">    <span class="comment">//二分法</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-5</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(r * <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有N个元素，编号1.2..N，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。<br>注意：不存在两个元素大小相等的情况。<br>也就是说，元素的大小关系是N个点与N*(N-1)/2条有向边构成的任意有向图。<br>然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过10000次提问来获取信息，每次提问只能了解某两个元素之间的关系。<br>现在请你把这N个元素排成一行，使得每个元素都小于右边与它相邻的元素。<br>你可以通过我们预设的bool函数compare来获得两个元素之间的大小关系。<br>例如，编号为a和b的两个元素，如果元素a小于元素b,则compare（a,b）返回true，否则返回false。<br>将N个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。</p>
</blockquote>
<p>我们可以尝试，将这种大小关系转换成曲线来表示，假如我们现在将第i个数插入已经排好的数列中，当它比数列中a元素小的时候，那么a就表示成一个下划线；当它比a元素大的时候，就表示成一个上划线。可以表示成下图：<br><img src="https://img-blog.csdnimg.cn/20200814110037180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基于此，我们可以利用二分来寻找曲线的极大值，然后插入即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of compare API.</span></span><br><span class="line"><span class="comment">// bool compare(int a, int b);</span></span><br><span class="line"><span class="comment">// return bool means whether a is less than b.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">specialSort</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//res用来存放排好的数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = res.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compare(res[mid], i)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="comment">//将i插到找到的位置，利用插入排序的方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">2</span>; j &gt; r; j--) swap(res[j], res[j + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//有可能整个曲线是单调递减的，这样的话我们需要补充边界条件</span></span><br><span class="line">            <span class="keyword">if</span> (compare(i, res[r])) swap(res[r], res[r + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过二分查找可以满足访问次数低于10000次的要求。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2020/08/14/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><blockquote>
<p>地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。注意：不同目标可能在同一位置。<br>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和x，y轴平行。<br>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
</blockquote>
<p>前缀和的定义就是对于当前数组，第i个数以前的数的总和，形成一个新的数组，即前缀和数组。$sum[i]=\sum_{j=0}^{i}num[i]$<br>以上是一维情况，对于二维数组，我们可以把它看成一个矩形，当前点的前缀和就是所在行以前和所在列以前所有数的总和$sum[i][j]=\sum_{m=0}^{i}\sum_{n=0}^{j}num[i][j]$<br>可以表示成下图的形式，对于黄色框内的前缀和，就是黄色=绿色+红色-蓝色。<br><img src="https://img-blog.csdnimg.cn/20200813092853480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对于这题，我们就可以用二维前缀和进行快速求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//M是二维数组最大范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5010</span>;</span><br><span class="line"><span class="comment">//记录二维数组每个点的价值, 初始化为0，记作全局变量，存储在堆空间，防止栈满。</span></span><br><span class="line"><span class="keyword">int</span> g[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//输入N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,</span></span><br><span class="line">	<span class="comment">//R表示爆炸范围</span></span><br><span class="line">    <span class="keyword">int</span> N, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="comment">//n和m用来记录最大边界</span></span><br><span class="line">    <span class="keyword">int</span> n = R, m = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, x, y, w; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        <span class="comment">//处理边界，从1开始</span></span><br><span class="line">        x++, y++;</span><br><span class="line">        n=max(n,x), m=max(m,y);</span><br><span class="line">        g[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            g[i][j] += g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>] - g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历前缀和，求解最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=R; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=R; j&lt;=m; j++)</span><br><span class="line">            res=max(res,g[i][j]-g[i-R][j]-g[i][j-R]+g[i-R][j-R]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以进一步简化代码，在计算前缀和的同时求解最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="keyword">int</span> n = R, m = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, x, y, w; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        x++, y++;</span><br><span class="line">        n=max(n,x), m=max(m,y);</span><br><span class="line">        g[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">            g[i][j] += g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>] - g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            x=max(i-R, <span class="number">0</span>);</span><br><span class="line">            y=max(j-R, <span class="number">0</span>);</span><br><span class="line">            res=max(res,g[i][j]-g[x][j]-g[i][y]+g[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>差分的定义就是，对于给定的数组$num$，第i个数和第i-1的差值所组成的新的数组就是差分数组，$dif[i]=num[i]-num[i-1]$（$dif[0]=num[0]$)。<br>对于差分数组和原数组存在如下关系<br>$num[i]=dif[0]+dif[1]+···+dif[i]<br>            =num[0]+num[1]-num[0]+···+num[i]-num[i-1]$</p>
<blockquote>
<p>给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。<br>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
</blockquote>
<p>利用差分数组，对于某个区间（l, r）内加1，只需$b[l]+=1,b[r]-=1$，这样就可以在$O(1)$时间复杂度更改，而不用遍历（l，r）范围内的数组。<br>借用差分数组，我们只需将差分数组全部变为0，就可以使原数组的数全部相同。而对于可执行的操作，我们可以分成如下4类：</p>
<ol>
<li>1&lt;=i，j&lt;=n               该操作是针对i，j范围，必然伴随差分数组某两个数的加1以及减1</li>
<li>i=0, 1&lt;=j&lt;=n            该操作是针对j以前的所有数，只伴随着差分数组某个数的加1或者减1</li>
<li>1&lt;=i&lt;=n, j=n+1        该操作是针对i以后的所有数，同上</li>
<li>i=0, j=n+1                该操作是针对数组全部 差分数组不变</li>
</ol>
<p>对于第一种情况一次操作可以更改差分数组的两个数，是我们应该优先选择的，通过加减两个差分数组的数，可以使得数组中的正数和负数相抵消，最后再用第二种和第三种方法对剩余的正数或者负数进行清零。如此满足最少操作的要求。第四种操作没有意义。</p>
<p>我们需要知道一点，当差分数组正数之和和负数之和相等的时候，利用第一种方式对差分数组清零，无论操作顺序是什么样的，整个数组得到的结果都是一样的，都是和初始数组首末值相等的数组。因此我们可以得出，对于最终数组的可能情况仅仅取决于对剩余正数或者负数的操作。<br>而对于剩余数的操作只有第二种和第三种方式，两种方式的可能组合的方式数，就是最终解。直观一点来看，例如我们最终剩余正数是下图左边所示：<br><img src="https://img-blog.csdnimg.cn/20200813111323564.png#pic_center" alt="在这里插入图片描述"><br>黑线代表了差分数组还有两个正数差值，均是1，因此我们最终通过第2，3种方法，可以使原数组有红黄蓝三种方式使差分数组清零。最终代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="comment">//接受数组</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//生成差分数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n; i&gt;<span class="number">1</span>; i--) a[i]-=a[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算差分数组正负数总和</span></span><br><span class="line">    LL pos=<span class="number">0</span>, neg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>) pos+=a[i];</span><br><span class="line">        <span class="keyword">else</span> neg-=a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(pos, neg) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(pos-neg)+<span class="number">1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。<br>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。<br>现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。<br>但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。<br>求每头牛的身高的最大可能值是多少。</p>
</blockquote>
<p>这道题我们可以很明确的知道，数组首位的牛最高值就是H，因为给定的M对关系仅仅是数组内部的关系。所以根据于此，我们可以利用差分数组记录每对关系，在根据首位来确定原数组最理想的形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n是牛的数量，p是第几头牛最高，h是最高的牛的高度，m是关系数。</span></span><br><span class="line">    <span class="keyword">int</span> n, p, h, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m;</span><br><span class="line">    height[<span class="number">1</span>]=h;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据关系，对差分数组的边界进行处理</span></span><br><span class="line">    <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; existed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, a, b; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">        <span class="keyword">if</span>(!existed.count(&#123;a, b&#125;))&#123;</span><br><span class="line">            existed.insert(&#123;a, b&#125;);</span><br><span class="line">            height[a+<span class="number">1</span>]--, height[b]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据差分数组，求解原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        height[i] += height[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; height[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/09/07/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="防晒"><a href="#防晒" class="headerlink" title="防晒"></a>防晒</h4><blockquote>
<p>有C头奶牛进行日光浴，第i头奶牛需要minSPF[i]到maxSPF[i]单位强度之间的阳光。<br>每头奶牛在日光浴前必须涂防晒霜，防晒霜有L种，涂上第i种之后，身体接收到的阳光强度就会稳定为SPF[i]，第i种防晒霜有cover[i]瓶。<br>求最多可以满足多少头奶牛进行日光浴。</p>
</blockquote>
<p>先将每头奶牛按照需要的minSPF排序。将防晒霜排序，从后向前遍历，如落在某头奶牛的minSPF、maxSPF区间内，则结果加+1，表示成下图。<br><img src="https://img-blog.csdnimg.cn/2020082409401958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>上面的小线段表示的就是每头奶牛的minSPF,maxSPF区间，下面横线的点代表防晒霜的SPF，我们从后向前遍历奶牛，若某个防晒霜落在我们的区间就配对成功，同时有多个防晒霜落入的话，我们选取最大的防晒霜。我们可以利用反证法，来证明正确性。<br>想增加配对数，我们必然要将当前防晒霜给某一个没有配对的区间。我们可知给后面的区间是不成立的，因为我们是从后向前配对的。所以我们只能给前面的没有配对的空间，我们可以表示成下图。<br><img src="https://img-blog.csdnimg.cn/20200824101833830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>若将红色防晒霜给之前没有配对的绿色区间，因为我们每次选择防晒霜的时候都是选择区间内最大的防晒霜，因此我们可知红色防晒霜之后没有落在蓝色区间的了，并且红色防晒霜之前也没有防晒霜，否则绿色区间就不会没有配对了，所以蓝色区间将不能配对。可知并没有改变结果数，所以无论向前还是向后交换最终得到的结果数不会大于我们的方法，得证。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cow是奶牛的区间，spf是防晒霜的值和数量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; cow;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; spf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//c是奶牛数量，l是防晒霜数，minspf和maxspf是区间范围，s是防晒霜的值，cover是每种防晒霜数量，res是配对数</span></span><br><span class="line">    <span class="keyword">int</span> c, l, minspf, maxspf, s, cover, res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; l;</span><br><span class="line">    <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; minspf &gt;&gt; maxspf;</span><br><span class="line">        cow.push_back(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(minspf, maxspf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; cover;</span><br><span class="line">        <span class="comment">//因为有可能有重复值输入，要累加到一起。</span></span><br><span class="line">        spf[s]+=cover;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将奶牛排序</span></span><br><span class="line">    sort(cow.begin(), cow.end());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从后向前遍历奶牛</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=cow.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">    	<span class="comment">//upper_bound可以找到大于区间右端点的第一个key。</span></span><br><span class="line">        <span class="keyword">auto</span> iter = --spf.upper_bound(cow[i].second);</span><br><span class="line">        <span class="keyword">if</span>(iter-&gt;first &lt;= cow[i].second &amp;&amp; iter-&gt;first &gt;= cow[i].first)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            iter -&gt; second --;</span><br><span class="line">            <span class="keyword">if</span>(!iter-&gt;second) spf.erase(iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="畜栏预定"><a href="#畜栏预定" class="headerlink" title="畜栏预定"></a>畜栏预定</h4><blockquote>
<p>有N头牛在畜栏中吃草。<br>每个畜栏在同一时间段只能提供给一头牛吃草，所以可能会需要多个畜栏。<br>给定N头牛和每头牛开始吃草的时间A以及结束吃草的时间B，每头牛在[A,B]这一时间段内都会一直吃草。<br>当两头牛的吃草区间存在交集时（包括端点），这两头牛不能被安排在同一个畜栏吃草。<br>求需要的最小畜栏数目和每头牛对应的畜栏方案。</p>
</blockquote>
<p>我们可以把牛的吃草时间看成一段区间，问题就变成求解最少的集合数，使得集合中所有区间无交集。对于某一区间，与之前所有集合中的元素均存在交集，那么我们就要新开辟一个集合。<br>对于每个区间，我们可以按左端点进行排序，依次将当前区间与之前创立的集合最右端点进行比较，若均存在交集，那么新建一集合。若不存在交集，那么我们可以将区间插入任意一个满足条件的集合，因为我们已经将区间排序，所以无论插入哪个集合对后续区间没有影响。进一步简化比较过程，利用小顶堆动态维护所有集合中的最小右端点，每次直接与堆顶比较即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line">priority_queue&lt;pii, <span class="built_in">vector</span>&lt;pii&gt;, greater&lt;pii&gt;&gt; q;</span><br><span class="line"><span class="keyword">int</span> res[<span class="number">50010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//储存牛的信息，包括开始时间，结束时间，以及序号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cowinfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;cowinfo&gt; cow;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两头牛的排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> cowinfo a, <span class="keyword">const</span> cowinfo b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l &lt; b.l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.l == b.l) <span class="keyword">return</span> a.r &lt;= b.r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n牛的数量，a，b吃草开始和结束时间，index是序号</span></span><br><span class="line">    <span class="keyword">int</span> n, a, b, index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        cow.push_back(cowinfo&#123;a, b, index++&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将牛的吃草开始时间排序</span></span><br><span class="line">    sort(cow.begin(), cow.end(), cmp1);</span><br><span class="line">    </span><br><span class="line">    index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	<span class="comment">//如果堆为空或者堆顶元素小于当前牛吃草开始时间，那么将当前牛插入堆顶栅栏</span></span><br><span class="line">        <span class="keyword">if</span>(q.size() &amp;&amp; cow[i].l&gt;q.top().first)&#123;</span><br><span class="line">            res[cow[i].num] = q.top().second;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则新开一个栅栏</span></span><br><span class="line">        <span class="keyword">else</span> res[cow[i].num] = index++;</span><br><span class="line">        q.push(pii(cow[i].r, res[cow[i].num]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; index - <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="雷达设备"><a href="#雷达设备" class="headerlink" title="雷达设备"></a>雷达设备</h4><blockquote>
<p>假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。<br>每个小岛都位于海洋一侧的某个点上。<br>雷达装置均位于海岸线上，且雷达的监测范围为d，当小岛与某雷达的距离不超过d时，该小岛可以被雷达覆盖。<br>我们使用笛卡尔坐标系，定义海岸线为x轴，海的一侧在x轴上方，陆地一侧在x轴下方。<br>现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。</p>
</blockquote>
<p>我们可以把岛屿可检测范围映射到海岸线上的一个区间，如下图：<br><img src="https://img-blog.csdnimg.cn/20200826095328451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因此，问题可以转换为若干个区间，找到最少的点，使得所有区间内都有点被包含。<br>我们可以将区间右端点排序，选取第一个区间的右端点建立雷达，看后续区间有多少可以包含这一点，直到该点不能被某个区间包含，我们则再以这一区间右端点建立雷达，以此类推。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; pdd;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pdd&gt; land;</span><br><span class="line"><span class="keyword">int</span> n, d, x, y;</span><br><span class="line"><span class="keyword">double</span> l, r, eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求解点到线的映射</span></span><br><span class="line"><span class="function">pdd <span class="title">get_range</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l = x - <span class="built_in">sqrt</span>(d*d - y*y);</span><br><span class="line">    r = x + <span class="built_in">sqrt</span>(d*d - y*y);</span><br><span class="line">    <span class="keyword">return</span> pdd(r, l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n表示岛屿数，d表示雷达监测范围</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	<span class="comment">//x,y是岛屿坐标</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="comment">//如果y大于d说明该岛屿检测不到，不存在方案数</span></span><br><span class="line">        <span class="keyword">if</span>(y&gt;d)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        land.push_back(get_range());</span><br><span class="line">    &#125;</span><br><span class="line">    sort(land.begin(), land.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	<span class="comment">//如果当前雷达不在当前区间范围内，那么新建一个雷达</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || pos &lt; land[i].second - eps) &#123;</span><br><span class="line">            pos = land[i].first;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="国王游戏"><a href="#国王游戏" class="headerlink" title="国王游戏"></a>国王游戏</h4><blockquote>
<p>恰逢 H 国国庆,国王邀请 n 位大臣来玩一个有奖游戏。<br>首先,他让每个大臣在左、右手上面分别写下一个整数,国王自己也在左、右手上各写一个整数。<br>然后,让这 n 位大臣排成一排,国王站在队伍的最前面。<br>排好队后,所有的大臣都会获得国王奖赏的若干金币,每位大臣获得的金币数分别是:<br>排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数,然后向下取整得到的结果。<br>国王不希望某一个大臣获得特别多的奖赏,所以他想请你帮他重新安排一下队伍的顺序,使得获得奖赏最多的大臣,所获奖赏尽可能的少。<br>注意,国王的位置始终在队伍的最前面。</p>
</blockquote>
<p>我们先假设已经排好序，那么对于第i个大臣和第i+1个大臣，交换前后的结果可以表示成下表：<br>|  |颠倒前|颠倒后|<br>|–|–|–|<br>|i位置| $L_{1}L_{2}···L_{i-1}/R_{i}$| $L_{1}L_{2}···L_{i-1}/R_{i+1}$ |<br>|i+1位置| $L_{1}L_{2}···L_{i-1}L_{i}/R_{i+1}$ | $L_{1}L_{2}···L_{i-1}L_{i+1}/R_{i}$ |<br>其中$L_{i}$代表第i个大臣左手的数字，$R_{i}$同理。进一步化简。<br>|  |颠倒前|颠倒后|<br>|–|–|–|<br>|i位置| $R_{i+1}$| $R_{i}$ |<br>|i+1位置| $L_{i}R_{i}$ | $L_{i+1}R_{i+1}$ |<br>我们可知，若$L_{i+1}R_{i+1}&gt;L_{i}R_{i}$，则颠倒后的结果一定大于等于颠倒前的结果，所以我们可以按照每位大臣的左右手乘积之和排序。代码如下，因为涉及到累乘，所以要用高精度乘除法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n代表大臣的个数，a，b代表每位大臣的左右手数字，sum是累乘结果，res是最终答案，minister是大臣左右手和两者乘积的信息</span></span><br><span class="line"><span class="keyword">int</span> n, a, b;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum, res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">minister</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, multi;</span><br><span class="line">&#125;nums[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//大臣比较函数，以乘积排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(minister&amp; x, minister&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.multi &lt; y.multi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度乘法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//flag是进位</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//模拟乘法，从低位开始</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=sum.size()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        flag += num * sum[i];</span><br><span class="line">        sum[i] = flag % <span class="number">10</span>;</span><br><span class="line">        flag /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果最终还有进位，就添加到数组前</span></span><br><span class="line">    <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        sum.insert(sum.begin(), flag % <span class="number">10</span>);</span><br><span class="line">        flag /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度除法</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">devision</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="comment">//ans是结果，flag是进位，signal表示当前是否已经开始有非0结果</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> signal = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sum.size(); i++)&#123;</span><br><span class="line">    	<span class="comment">//如果当前结果可以除num非0，则保存整除结果，并进位，</span></span><br><span class="line">    	<span class="comment">//如果除num结果是0，并且已经开始有非0结果，该位置0</span></span><br><span class="line">        flag = flag * <span class="number">10</span> + sum[i];</span><br><span class="line">        <span class="keyword">if</span>(flag / num)&#123;</span><br><span class="line">            ans.push_back(flag / num);</span><br><span class="line">            flag %= num;</span><br><span class="line">            signal = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(signal) ans.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector比较，先比较长度，在用vector自带比较</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans.size() &lt; res.size()) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans.size() &gt; res.size()) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans &gt; res) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nums[i].l &gt;&gt; nums[i].r;</span><br><span class="line">        nums[i].multi = nums[i].r * nums[i].l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序，除国王第一位</span></span><br><span class="line">    sort(nums+<span class="number">1</span>, nums+n+<span class="number">1</span>, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++)&#123;</span><br><span class="line">		<span class="comment">//形成数组</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[<span class="number">0</span>].l;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                sum.insert(sum.begin(), temp % <span class="number">10</span>);</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="comment">//除法</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = devision(nums[i].r);</span><br><span class="line">            <span class="comment">//比较</span></span><br><span class="line">            res = compare(ans);</span><br><span class="line">            <span class="comment">//累乘</span></span><br><span class="line">            multiply(nums[i].l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.size(); i++) <span class="built_in">cout</span> &lt;&lt; res[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="给树染色"><a href="#给树染色" class="headerlink" title="给树染色"></a>给树染色</h4><blockquote>
<p>一颗树有 n 个节点，这些节点被标号为：1,2,3…n，每个节点 i 都有一个权值 A[i]。<br>现在要把这棵树的节点全部染色，染色的规则是：<br>根节点R可以随时被染色；对于其他节点，在被染色之前它的父亲节点必须已经染上了色。<br>每次染色的代价为T*A[i]，其中T代表当前是第几次染色。<br>求把这棵树染色的最小总代价。</p>
</blockquote>
<p>对于两个节点，$a&gt;b$，那么理所当然我们要优先染a，其次b。若是a还有个父节点p需要在a之前染色，那么a、b、p染色顺序是什么呢？我们假设先染p，接下来因为$a&gt;b$，则染a，最后是b，如此得到的代价就是$1p+2a+3b$。如果我们先染b，再p和a，得到的代价就是$1b+2p+3a$。先染b的前提就是$1p+2a+3b&gt;1b+2p+3a$，即$b&gt;(a+p)/2$，将结论进一步扩展，对于两组节点，我们应该先染平均值大的那组节点。<br>因此，我们的解决办法就是每次选取平均值大的一组（或者一个）节点，将其放到其父节点之后，和父节点形成一组，继续选取。最终算法复杂度就是$O(n^{2})$。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点信息，s表示组内有多少节点，v表示节点代价，p存储的是父节点序号，avg是组内节点代价均值。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, v, p;</span><br><span class="line">    <span class="keyword">double</span> avg;</span><br><span class="line">&#125;node[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//n表示节点个数，r是根节点序号，b的父节点是a。</span></span><br><span class="line"><span class="keyword">int</span> a, b, n, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到当前均值最大的节点组，根节点除外。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">double</span> avg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != r &amp;&amp; node[i].avg &gt; avg)&#123;</span><br><span class="line">            avg = node[i].avg;</span><br><span class="line">            res = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].v;</span><br><span class="line">        node[i].avg = node[i].v;</span><br><span class="line">        node[i].s = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//ans是最终结果</span></span><br><span class="line">        ans += node[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        node[b].p = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环n-1次，因为根节点不用考虑，一定排在首位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">    	<span class="comment">//找到当前均值最大的节点组的根节点序号</span></span><br><span class="line">        <span class="keyword">int</span> num = find();</span><br><span class="line">        <span class="comment">//找到该节点组跟节点的父节点</span></span><br><span class="line">        <span class="keyword">int</span> parent = node[num].p;</span><br><span class="line">        <span class="comment">//将该节点组添加到父节点组的末尾，则节点组的代价就会推迟父节点组内的节点个数时间</span></span><br><span class="line">        ans += node[parent].s * node[num].v;</span><br><span class="line">        <span class="comment">//找到所有父节点是当前节点组跟节点的节点，更换父节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">            <span class="keyword">if</span>(node[j].p == num)</span><br><span class="line">                node[j].p = parent;</span><br><span class="line">        <span class="comment">//跟新父节点信息</span></span><br><span class="line">        node[parent].v += node[num].v;</span><br><span class="line">        node[num].avg = <span class="number">-1</span>;</span><br><span class="line">        node[parent].s += node[num].s;</span><br><span class="line">        node[parent].avg = (<span class="keyword">double</span>) node[parent].v / node[parent].s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与递推</title>
    <url>/2020/08/10/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h4 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选取任意多个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//达到n时输出</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不选当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state);</span><br><span class="line">	<span class="comment">//选择当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选出m个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，sum代表选取了多少个数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//当选不够m个的时候返回，剪枝处理</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n - u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//当选够m个的时候输出</span></span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			    <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前数字被选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//当前数字未选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h4><blockquote>
<p>把1~n这n个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果u等于n，则输出当前的排列</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : path) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对于当前第u位，将未选的数字填入，然后递归</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">			path.push_back(i + <span class="number">1</span>);</span><br><span class="line">			dfs(u + <span class="number">1</span>, state | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">			path.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h4><blockquote>
<p>你玩过拉灯游戏吗？25盏灯排成一个5x5的方形。每个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应；和这个灯上下左右相邻的灯也要相应地改变状态。<br>我们用数字“1”表示驿站开着的灯，用数字“0”表示关着的灯。下面这种状态<br>10111<br>01101<br>10111<br>10000<br>11011<br>在改变了最左上角的灯的状态后将变成：<br>01111<br>11101<br>10111<br>10000<br>11011<br>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步之内使所有的灯都变亮。</p>
</blockquote>
<p>我们可以知道对于一些要按的灯，按灯顺序不会影响最终灯的状态。那么我们可以把这个问题逐行分解，对于第一行我们将可能的按法全部枚举，对于后续行我们的目标就是使得前一行的灯全部按亮。由此判断可不可以在6次内全部按亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//g数组存放灯的状态，dx和dy用来表示邻近灯</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//turn函数会修改当前灯与周围灯的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">5</span> &amp;&amp; b &gt;=<span class="number">0</span> &amp;&amp; b &lt; <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="comment">//g[a][b] = '1' - g[a][b] + '0';</span></span><br><span class="line">			g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ans代表可能全亮的最少按灯次数</span></span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	<span class="comment">//遍历第一行可能的按法</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">1</span>&lt;&lt;<span class="number">5</span>; k++)&#123;</span><br><span class="line">		<span class="comment">//res代表按灯次数</span></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(k &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">				res++;</span><br><span class="line">				turn(<span class="number">0</span>, j);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//根据当前行出现的灭灯，修改下一行对应位置的灯</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">				<span class="keyword">if</span>(g[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">					res++;</span><br><span class="line">					turn(i + <span class="number">1</span>, j);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="comment">//观察最后一行灯是否全亮，如果全亮将按灯次数与之前比较</span></span><br><span class="line">		<span class="keyword">bool</span> is_successful = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(g[<span class="number">4</span>][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">				is_successful = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_successful) ans = min(ans, res);</span><br><span class="line">		<span class="built_in">memcpy</span>(g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">6</span>) ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; work() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h4><blockquote>
<p>汉诺塔问题，条件如下：</p>
</blockquote>
<ol>
<li>这里有A、B、C和D四座塔。</li>
<li>这里有n个圆盘，n的数量是恒定的， 且n&lt;=12。</li>
<li>每个圆盘的尺寸都不相同。</li>
<li>所有圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。</li>
<li>我们需要将所有的圆盘都从塔A转移到塔D上。</li>
<li>每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。<br>请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。<br><img src="https://img-blog.csdnimg.cn/20200809141024645.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>我们可以将其化为一个动态规划问题，对于三阶汉诺塔，我们可以将问题描述为D[n] = DD[n-1] x 2 + 1，即先将前n-1个圆盘移到第二个塔上，再将最后一个圆盘放到第三个塔上（仅一步操作），最后将第二个塔上的圆盘全部移动到第三个塔上。</p>
<p>而对于四阶汉诺塔，我们要寻找一个合适的圆盘i，将其上的圆盘先移动到一个塔上，所需移动次数设为F[i]。然后再将其下的圆盘移动到最后一个塔上，此时就是三阶汉诺塔问题，D[n-i]。然后再将前i个圆盘移动到最后塔上，即F[i]。这个合适的圆盘i就是使得移动次数最少的圆盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d[<span class="number">15</span>], f[<span class="number">15</span>];</span><br><span class="line">	d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">12</span>; i++)&#123;</span><br><span class="line">		d[i] = <span class="number">1</span> + d[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">			f[i] = min(f[i], f[j] * <span class="number">2</span> + d[i - j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++) <span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><blockquote>
<p>假设现在有两个自然数A和B，S是$A^B$的所有约数之和。<br>请你求出S mod 9901的值是多少。</p>
</blockquote>
<p>对于数A，我们可以将其分解成质数的形式，A=${p_{1}}^{k_{1}}{p_{2}}^{k_{2}}···{p_{n}}^{k_{n}}$，其中${p_{n}}$是A的质数约数，我们可以修改${k_{n}}$的大小来获得不同的约数，对于所有的约数之和我们可以表示为：<br>$({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}})\times ({p_{2}}^{0}+{p_{2}}^{1}+\cdot \cdot \cdot +{p_{2}}^{k_{2}})\times \cdot \cdot \cdot \times ({p_{n}}^{0}+{p_{n}}^{1}+\cdot \cdot \cdot +{p_{n}}^{k_{n}})$<br>对于每一部分，我们还可以进一步化简，例如，当$k_1$是奇数的时候，我们可以化简为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}}$<br>$= {p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2}+{p_{1}}^{k_{1}/2+1}\times ({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2})$<br>其中/代表着整数除法<br>如果$k_n$为偶数，那么就提出一个$p_n$即可，这样利用递归我们可以加速求解<br>而对于${p_{1}}^{k_{1}/2+1}$我们可以利用快速幂进行求解（参考上一博客位运算）。如下是代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//如果k是偶数就提出一个P，则k-1变为奇数</span></span><br><span class="line">	<span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (p % mod * sum(p, k - <span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="comment">//如果k是奇数</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> + qmi(p, k/<span class="number">2</span> + <span class="number">1</span>)) * sum(p, k/<span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A, B;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=A; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(A % i ==<span class="number">0</span>)&#123;</span><br><span class="line">			s++;</span><br><span class="line">			A /= i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s) res = res * sum(i, s * B) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!A) res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h4><blockquote>
<p>城市的规划在城市建设中是个大问题。<br>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。<br>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200810085620117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="city.png">当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。<br>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。<br>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。<br>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。</p>
</blockquote>
<p>我们可以发现每一等级的城市都是由上一等级城市旋转平移得到的，所以对于该题，我们可以将n等级的城市进行递归，从1等级开始处理。<br>将城市划分成四个区域，左上、右上、左下、右下四个分区，根据所在分区决定上一等级城市该如何旋转平移。然后再将得到的当前等级城市下的坐标，传递给下一等级的城市，直至规定等级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="function">PLL <span class="title">calc</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//边界结果</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//len代表当前等级下城市边长的一半（移动上一等级城市需要），cnt表示当前等级城市下街道数量的1/4（决定分区）</span></span><br><span class="line">    ll len=<span class="number">1L</span>L&lt;&lt;(n<span class="number">-1</span>),cnt=<span class="number">1L</span>L&lt;&lt;(<span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递归到最低级城市</span></span><br><span class="line">    PLL pos=calc(n<span class="number">-1</span>,m%cnt);</span><br><span class="line">    ll x=pos.first,y=pos.second;</span><br><span class="line">    <span class="comment">//z表示当前等级城市下，m序号的街道所处的分区，分为左上、右上、左下、右下四个分区，从而决定如何旋转</span></span><br><span class="line">    ll z=m/cnt;</span><br><span class="line">    <span class="comment">//根据分区位置旋转平移上一等级的街道，其中（x,y）代表上一等级城市下街道的位置</span></span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(y,x);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x,y+len);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x+len,y+len);</span><br><span class="line">    <span class="keyword">return</span> make_pair(<span class="number">2</span>*len<span class="number">-1</span>-y,len<span class="number">-1</span>-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n,a,b;</span><br><span class="line">        <span class="comment">//这里n代表当前城市等级，a、b代表两个街道的序号</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//简化边界处理，将序号从0开始</span></span><br><span class="line">        PLL x=calc(n,a<span class="number">-1</span>);</span><br><span class="line">        PLL y=calc(n,b<span class="number">-1</span>);</span><br><span class="line">        ll dx=x.first-y.first,dy=x.second-y.second;</span><br><span class="line">        <span class="keyword">double</span> ans=(<span class="built_in">sqrt</span>(dx*dx+dy*dy)*<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归改递推"><a href="#递归改递推" class="headerlink" title="递归改递推"></a>递归改递推</h4><p>用递推来实现递归代码，需要借助STL中的栈，计算机本身在处理递归代码的时候也是使用栈来实现的。</p>
<p>在这里我们通过“递归实现组合型枚举”来举例说明，我们首先要把原递归代码划分位置，用来标记处理过程。通过定义结构体，作为栈的保存对象，其中要包含标记位置。主函数中我们循环取出栈首元素，根据所标记的位置来决定如何处理当前元素，直至栈空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos, u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n _ u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.yop;</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.pos == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">					<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			t.pos = <span class="number">1</span>;</span><br><span class="line">			stk.push(t);</span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t.pos == <span class="number">1</span>)&#123;</span><br><span class="line">			t.pos = <span class="number">2</span>;<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(t);<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//可去掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记位置的方法只是个通用模板，我们可以将得到的递推继续优化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">				<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        stk.push(&#123;t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		stk.push(&#123;t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增算法</title>
    <url>/2020/09/02/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:<br>从集合 S 中取出 M 对数(即 2∗M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。<br>现在给定一个长度为 N 的数列 A 以及一个整数 T。<br>我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。<br>求最少需要分成几段。</p>
</blockquote>
<p>看见“使得平方之和最大”、“最少需要分成几段”就能发现该题是求解最大最小问题，最开始想到的就应该是二分查找，二分查找是解决最大最小问题最常用的办法。<br>对于差的平方之和最大，我们可以证明，将最大与最小做差的平方+次大次小做差的平方+···，此时的差的平方之和最大，可以用多项式展开来证明。并且M对数的数量是不定的，因此排序算法是不可避免的。<br>综上，我们应该用二分来确定每一段的长度，若分成n段则最坏时间复杂度在$O(n)$，每段又要调用$O(logn)$次二分，在每次二分又要用排序算法进行求解$O(nlogn)$。所以总的算法复杂度在$O(n^{2}log^{2}n)$，但经过严谨的数学证明应该是$O(n^{2}logn)$。</p>
<p>除了二分以外是否有更好的方法来减低时间复杂度，解决这个问题呢？那就是“倍增”，考虑如下问题</p>
<blockquote>
<p>对于给定一个正整数数列，已知其前缀和，如何快速求出从哪位元素开始，之前的所有元素总和大于sum。</p>
</blockquote>
<p>这题我们就可以用<a href="https://blog.csdn.net/weixin_41676930/article/details/107971905" target="_blank" rel="noopener">前缀和</a>的思想来解决，常规方法可能是用二分，但一定会耗费$logn$的时间。如果用朴素算法，则更需要$n$的时间。如果我们在朴素算法上进行改进，遍历前缀和的时候步长是动态变化的，而不是固定为1，遵循以下规则：</p>
<ol>
<li>end = 0，步长len初始化为1</li>
<li>如果此时end + l所指代的前缀和小于sum，那么我们就将l乘以2，扩大结尾end = end + l</li>
<li>如果此时end + l所指代的前缀和大于等于sum，那么我们就将l除以2</li>
<li>如果l == 0，那么此时就收敛到了结果</li>
</ol>
<p>相比于二分查找的好处就是，倍增在最差的情况下也才需要$O(logn)$的时间，而假如所求解越靠近队首，求解时间越短，平均时间复杂度要优于二分。</p>
<p>因此我们考虑用倍增来进一步优化求解，如果使用倍增，那么我们的时间复杂度可以降低为$O(nlog^{2}n)$，表示成如下图：<br><img src="https://img-blog.csdnimg.cn/2020082112474397.png#pic_center" alt="在这里插入图片描述"><br>如果最终结果要分成3段，长度分别是len1、len2和len3，那么在每一段，我们倍增查找用时就是$O(loglen1)$，排序用时就是$O(len1loglen1)$，因此每一段我们总用时就是$O(len1log^{2}len1)$。再将这若干段相加可以得到总的时间复杂度$O(nlog^{2}n)$，相比于二分要降低很多。</p>
<p>接下来，我们考虑进一步的优化。在上面的方法中，我们每倍增一段，就要重新计算整个区间的排序，可不可以利用归并排序的方法，当倍增一段，我们只计算倍增这一区间的排序，然后在利用之前的计算结果归并，这样的话就省去重复计算。<br>我们来看一下这样的时间复杂度，仍然以上图为例，假设最终结果分成3段，每一段排序的用时就是$O(len1loglen1)$，那么归并用时需要多久呢？我们知道每一段要进行$O(loglen1)$的时间，在这些时间里，我们要进行长度为1、2、4、8、······、2len1长度的归并排序，因此归并用时就是这些长度的累加和，利用等比数列求和可知结果是$O(len1)$的，所以每一段的用时就是$O(lenloglen + len)$，总用时就是各段用时相加，依旧是$O(nlogn + n)$。至此，我们明确了该题的最优解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n表示集合元素个数，t表示校验值，a、b、temp用来做排序运算，m是对数，res是结果</span></span><br><span class="line">ll n, t, a[N], b[N], temp[N];</span><br><span class="line"><span class="keyword">int</span> m, res;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> test)</span></span>&#123;</span><br><span class="line">	<span class="comment">//start表示当前要求解段的起始位置，end是当前小于校验值的结尾，test是要尝试的结尾</span></span><br><span class="line">	<span class="comment">//因为我们要对a数组进行排序，所以a数组end到test的顺序有可能之前已经被打乱，要拷贝b数组（原始数据）的内容</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=end + <span class="number">1</span>; i&lt;=test; i++) a[i] = b[i];</span><br><span class="line">    sort(a + end + <span class="number">1</span>, a + test + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//双指针归并</span></span><br><span class="line">    <span class="keyword">int</span> f = start, b = end+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//sum是最终这一段的校验值</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=test; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; test || f &lt;= end &amp;&amp; a[f]&lt;a[b]) temp[i] = a[f++];</span><br><span class="line">        <span class="keyword">else</span> temp[i] = a[b++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(test-start+<span class="number">1</span>&gt;&gt;<span class="number">1</span>) &amp;&amp; i&lt;m; i++)&#123;</span><br><span class="line">        sum += (temp[start+i]-temp[test-i]) * (temp[start+i]-temp[test-i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//start表示当前要求解段的起始位置，end是当前小于校验值的结尾，l是倍增长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, l;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; n)&#123;</span><br><span class="line">        l = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果倍增长度等于0，即收敛</span></span><br><span class="line">        <span class="keyword">while</span>(l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end + l &gt;= n || check(start, end, end + l) &gt; t) l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="comment">// 当前end+l结尾可以满足条件，那么我们就将之前排好的序保存下来，方便下次使用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end+l; i++) a[i]=temp[i];</span><br><span class="line">                end = end + l;</span><br><span class="line">                l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始下一段的寻找</span></span><br><span class="line">        start = ++end;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//k表示测试集组数</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
