<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/2020/07/14/test/</url>
    <content><![CDATA[<p>我是一个测试文件。</p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2020/08/09/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="C-位运算基本知识"><a href="#C-位运算基本知识" class="headerlink" title="C++位运算基本知识"></a>C++位运算基本知识</h1><h2 id="与"><a href="#与" class="headerlink" title="与"></a>与</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a与b表示</span></span><br><span class="line">a &amp; b</span><br></pre></td></tr></table></figure>

<h2 id="或"><a href="#或" class="headerlink" title="或"></a>或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a或b表示</span></span><br><span class="line">a | b</span><br></pre></td></tr></table></figure>

<h2 id="非"><a href="#非" class="headerlink" title="非"></a>非</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a非表示</span></span><br><span class="line">!a</span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><table>
<thead>
<tr>
<th>input_1</th>
<th>input_2</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a异或b表示</span></span><br><span class="line">a ^ b</span><br></pre></td></tr></table></figure>
<p>通过异或可以实现很多功能，例如模拟加法计算，快速找寻配偶等等。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码的提出的初衷就是希望计算机在运算的时候只使用加法<br>正数的补码和原码相同<br>负数的补码是取反码（符号位不变）以后再加1</p>
<h2 id="按位取反"><a href="#按位取反" class="headerlink" title="按位取反"></a>按位取反</h2><table>
<thead>
<tr>
<th>input</th>
<th>output</th>
</tr>
</thead>
<tbody><tr>
<td>00000001</td>
<td>11111110</td>
</tr>
<tr>
<td>10000001</td>
<td>01111110</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ a的按位取反</span></span><br><span class="line">~a</span><br></pre></td></tr></table></figure>
<p>通过按位取反，我们可以实现lowbit功能，即找寻某一数字，最低位的1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如输入10010100，可以返回00000100，即最低位1表示的数字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (~num + <span class="number">1</span>) &amp; num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="左移、右移"><a href="#左移、右移" class="headerlink" title="左移、右移"></a>左移、右移</h2><p>左移n位相当于，原数乘上2的n次方<br>右移n位相当于，原数除以2的n次方<br>移位又分为算术移位和逻辑移位，C++和Python都是算数移位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C++ a左移n位</span></span><br><span class="line">a &lt;&lt; n;</span><br><span class="line"><span class="comment">//C++ a右移n位</span></span><br><span class="line">a &gt;&gt; n;</span><br></pre></td></tr></table></figure>

<h1 id="位运算例题"><a href="#位运算例题" class="headerlink" title="位运算例题"></a>位运算例题</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote>
<p>题目1：求a的b次方对p取模的值</p>
</blockquote>
<p>首先我们会想到直接使用cmath头文件的pow函数可以很快求解。但pow函数在运算会返回double类型，如果输入数据过大就会溢出。<br>如果利用循环求解，每个循环中再求模，效率又太低。因此我们可以使用快速幂来加速我们的代码执行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = res * <span class="number">1l</span>l * a % p;</span><br><span class="line">		a = a * <span class="number">1l</span>l * a % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题目2：求a乘b对p取模的值</p>
</blockquote>
<p>类比上题求解方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ULL a, b, p;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">	ULL res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = (res + a) % p;</span><br><span class="line">		a = a * <span class="number">2</span> % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h2><blockquote>
<p>给定一张 n 个点的带权无向图，点从 0~n-1 标号，求起点 0 到终点 n-1 的最短Hamilton路径。 Hamilton路径的定义是从 0 到 n-1 不重不漏地经过每个点恰好一次。</p>
</blockquote>
<p>旅行商问题，是NP完全问题，目前还不能在多项式时间内求解，我们能做的就是优化暴力求解，本方法采用了状态压缩动态规划的方法加速计算。<br>我们定义一个状态用来表示哪些点我们已经到达，哪些点我们还没有访问到，用state来表示。<br>例如，state=001011，表示第0，1，3点已经访问。<br>我们设一个函数 f[state][j] ，表示当前走到 j 点的路径长度，我们的目标是求解 f[0111…1][n-1] ，并使其最短，采用动态规划可以表示成下式：<br>f[state][j] = min(f[state][j]，f[state_j][k] + weight[k][j]）<br>其中state_j代表着state将j点置0，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f[M][N], weight[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; weight[i][j];</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; ++j)</span><br><span class="line">			<span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; ++k)</span><br><span class="line">					<span class="keyword">if</span>(i-(<span class="number">1</span> &lt;&lt; j) &gt;&gt; k &amp; <span class="number">1</span>)</span><br><span class="line">						f[i][j]=min(f[i][j], f[i-(<span class="number">1</span>&lt;&lt;j)][k] + weight[k][j]);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) <span class="number">-1</span>][n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2020/08/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="二分查找算法模板"><a href="#二分查找算法模板" class="headerlink" title="二分查找算法模板"></a>二分查找算法模板</h4><p>二分模板有两种，适用于不同情况。</p>
<h5 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h5><p>当区间[l, r]的更新操作是r=mid；l=mid+1时，计算mid不需要加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当区间[l, r]的更新操作是r = mid - 1; l = mid时，计算mid时需加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) l = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实数二分"><a href="#实数二分" class="headerlink" title="实数二分"></a>实数二分</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_real</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line">	<span class="comment">//也可以改成循环次数for (int k = 0; k &lt; 100; k++）</span></span><br><span class="line">	<span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (check()) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h5><p>我们将要求解的问题设成一个求解曲线极值的问题。我们每次将$l$和$r$进行三等分，得到mid_l和mid_r，比较mid_l和mid_r得到三种情况：</p>
<ol>
<li>f(mid_l)&gt;f(mid_r)  r=mid_r</li>
<li>f(mid_l)&lt;f(mid_r)  l=mid_l</li>
<li>f(mid_l)=f(mid_r) 且mid_l=mid_r，则得解 , 否则归为以上两类均可</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200814092307705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tsearch</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> mid_l, mid_r, eps=<span class="number">1e-6</span>;</span><br><span class="line">	<span class="keyword">while</span>(r - l &lt; eps)&#123;</span><br><span class="line">		mid_l = l + (l - r) / <span class="number">3</span>;</span><br><span class="line">		mid_r = l + <span class="number">2</span> * (l - r) / <span class="number">3</span></span><br><span class="line">		<span class="keyword">if</span> (fun(mid_l) &gt; fun(mid_r)) r=mid_r;</span><br><span class="line">		<span class="keyword">else</span> l=mid_l;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们这个曲线一定要是单调的，否则三分法就无效。</p>
<h4 id="二分查找例题"><a href="#二分查找例题" class="headerlink" title="二分查找例题"></a>二分查找例题</h4><blockquote>
<p>农夫约翰的农场由 N 块田地组成，每块地里都有一定数量的牛,其数量不会少于1头，也不会超过2000头。<br>约翰希望用围栏将一部分连续的田地围起来，并使得围起来的区域内每块地包含的牛的数量的平均值达到最大。<br>围起区域内至少需要包含 F 块地，其中 F 会在输入中给出。<br>在给定条件下，计算围起区域内每块地包含的牛的数量的平均值可能的最大值是多少。</p>
</blockquote>
<p>考虑二分查找平均值最大的牛的数量。对于判定条件，我们可以利用之前学过的<a href="https://blog.csdn.net/weixin_41676930/article/details/107971905" target="_blank" rel="noopener">前缀和</a>来辅助判定。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cows[N];</span><br><span class="line"><span class="keyword">double</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> avg)</span></span>&#123;</span><br><span class="line">	<span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i<span class="number">-1</span>] + cows[i] - avg;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断第j和前缀和是否大于第j-m的前缀和，大于则成立，否则不成立</span></span><br><span class="line">    <span class="keyword">double</span> minv = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = m; j &lt;= n; i++, j++)&#123;</span><br><span class="line">    	<span class="comment">//minv用来存储距离第j-m个数以前的最小值</span></span><br><span class="line">        minv = min(minv, sum[i]);</span><br><span class="line">        <span class="keyword">if</span> (sum[j] &gt;= minv) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n代表总的田地数，m代表至少包含的田地数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; cows[i];</span><br><span class="line">    <span class="comment">//二分法</span></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">1e-5</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(r * <span class="number">1000</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有N个元素，编号1.2..N，每一对元素之间的大小关系是确定的，关系具有反对称性，但不具有传递性。<br>注意：不存在两个元素大小相等的情况。<br>也就是说，元素的大小关系是N个点与N*(N-1)/2条有向边构成的任意有向图。<br>然而，这是一道交互式试题，这些关系不能一次性得知，你必须通过不超过10000次提问来获取信息，每次提问只能了解某两个元素之间的关系。<br>现在请你把这N个元素排成一行，使得每个元素都小于右边与它相邻的元素。<br>你可以通过我们预设的bool函数compare来获得两个元素之间的大小关系。<br>例如，编号为a和b的两个元素，如果元素a小于元素b,则compare（a,b）返回true，否则返回false。<br>将N个元素排好序后，把他们的编号以数组的形式输出，如果答案不唯一，则输出任意一个均可。</p>
</blockquote>
<p>我们可以尝试，将这种大小关系转换成曲线来表示，假如我们现在将第i个数插入已经排好的数列中，当它比数列中a元素小的时候，那么a就表示成一个下划线；当它比a元素大的时候，就表示成一个上划线。可以表示成下图：<br><img src="https://img-blog.csdnimg.cn/20200814110037180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基于此，我们可以利用二分来寻找曲线的极大值，然后插入即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of compare API.</span></span><br><span class="line"><span class="comment">// bool compare(int a, int b);</span></span><br><span class="line"><span class="comment">// return bool means whether a is less than b.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">specialSort</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//res用来存放排好的数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        res.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = res.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compare(res[mid], i)) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(i);</span><br><span class="line">            <span class="comment">//将i插到找到的位置，利用插入排序的方法</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = res.size() - <span class="number">2</span>; j &gt; r; j--) swap(res[j], res[j + <span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//有可能整个曲线是单调递减的，这样的话我们需要补充边界条件</span></span><br><span class="line">            <span class="keyword">if</span> (compare(i, res[r])) swap(res[r], res[r + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过二分查找可以满足访问次数低于10000次的要求。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>递归与递推</title>
    <url>/2020/08/10/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
    <content><![CDATA[<h4 id="递归实现指数型枚举"><a href="#递归实现指数型枚举" class="headerlink" title="递归实现指数型枚举"></a>递归实现指数型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选取任意多个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//达到n时输出</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不选当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state);</span><br><span class="line">	<span class="comment">//选择当前数字</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h4><blockquote>
<p>从1~n这n个整数中随机选出m个，输出所有可能的选择方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，sum代表选取了多少个数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line"> 	<span class="comment">//当选不够m个的时候返回，剪枝处理</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n - u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//当选够m个的时候输出</span></span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">			    <span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前数字被选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//当前数字未选</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h4><blockquote>
<p>把1~n这n个整数排成一行后随机打乱顺序，输出所有可能的次序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u代表当前进行的递归计数，state代表哪些数被选与未选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果u等于n，则输出当前的排列</span></span><br><span class="line">	<span class="keyword">if</span>(u == n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : path) <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对于当前第u位，将未选的数字填入，然后递归</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;</span><br><span class="line">			path.push_back(i + <span class="number">1</span>);</span><br><span class="line">			dfs(u + <span class="number">1</span>, state | (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">			path.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="费解的开关"><a href="#费解的开关" class="headerlink" title="费解的开关"></a>费解的开关</h4><blockquote>
<p>你玩过拉灯游戏吗？25盏灯排成一个5x5的方形。每个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应；和这个灯上下左右相邻的灯也要相应地改变状态。<br>我们用数字“1”表示驿站开着的灯，用数字“0”表示关着的灯。下面这种状态<br>10111<br>01101<br>10111<br>10000<br>11011<br>在改变了最左上角的灯的状态后将变成：<br>01111<br>11101<br>10111<br>10000<br>11011<br>给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步之内使所有的灯都变亮。</p>
</blockquote>
<p>我们可以知道对于一些要按的灯，按灯顺序不会影响最终灯的状态。那么我们可以把这个问题逐行分解，对于第一行我们将可能的按法全部枚举，对于后续行我们的目标就是使得前一行的灯全部按亮。由此判断可不可以在6次内全部按亮。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//g数组存放灯的状态，dx和dy用来表示邻近灯</span></span><br><span class="line"><span class="keyword">char</span> g[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//turn函数会修改当前灯与周围灯的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">turn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = x + dx[i], b = y + dy[i];</span><br><span class="line">		<span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">5</span> &amp;&amp; b &gt;=<span class="number">0</span> &amp;&amp; b &lt; <span class="number">5</span>)&#123;</span><br><span class="line">			<span class="comment">//g[a][b] = '1' - g[a][b] + '0';</span></span><br><span class="line">			g[a][b] ^= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//ans代表可能全亮的最少按灯次数</span></span><br><span class="line">	<span class="keyword">int</span> ans = INF;</span><br><span class="line">	<span class="comment">//遍历第一行可能的按法</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;<span class="number">1</span>&lt;&lt;<span class="number">5</span>; k++)&#123;</span><br><span class="line">		<span class="comment">//res代表按灯次数</span></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> backup[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(backup, g, <span class="keyword">sizeof</span> g);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(k &gt;&gt; j &amp; <span class="number">1</span>)&#123;</span><br><span class="line">				res++;</span><br><span class="line">				turn(<span class="number">0</span>, j);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//根据当前行出现的灭灯，修改下一行对应位置的灯</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">				<span class="keyword">if</span>(g[i][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">					res++;</span><br><span class="line">					turn(i + <span class="number">1</span>, j);</span><br><span class="line">				&#125;</span><br><span class="line">		<span class="comment">//观察最后一行灯是否全亮，如果全亮将按灯次数与之前比较</span></span><br><span class="line">		<span class="keyword">bool</span> is_successful = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>(g[<span class="number">4</span>][j] == <span class="string">'0'</span>)&#123;</span><br><span class="line">				is_successful = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(is_successful) ans = min(ans, res);</span><br><span class="line">		<span class="built_in">memcpy</span>(g, backup, <span class="keyword">sizeof</span> g);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">6</span>) ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) <span class="built_in">cin</span> &gt;&gt; g[i];</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; work() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="奇怪的汉诺塔"><a href="#奇怪的汉诺塔" class="headerlink" title="奇怪的汉诺塔"></a>奇怪的汉诺塔</h4><blockquote>
<p>汉诺塔问题，条件如下：</p>
</blockquote>
<ol>
<li>这里有A、B、C和D四座塔。</li>
<li>这里有n个圆盘，n的数量是恒定的， 且n&lt;=12。</li>
<li>每个圆盘的尺寸都不相同。</li>
<li>所有圆盘在开始时都堆叠在塔A上，且圆盘尺寸从塔顶到塔底逐渐增大。</li>
<li>我们需要将所有的圆盘都从塔A转移到塔D上。</li>
<li>每次可以移动一个圆盘，当塔为空塔或者塔顶圆盘尺寸大于被移动圆盘时，可将圆盘移至这座塔上。<br>请你求出将所有圆盘从塔A移动到塔D，所需的最小移动次数是多少。<br><img src="https://img-blog.csdnimg.cn/20200809141024645.png#pic_center" alt="在这里插入图片描述"></li>
</ol>
<p>我们可以将其化为一个动态规划问题，对于三阶汉诺塔，我们可以将问题描述为D[n] = DD[n-1] x 2 + 1，即先将前n-1个圆盘移到第二个塔上，再将最后一个圆盘放到第三个塔上（仅一步操作），最后将第二个塔上的圆盘全部移动到第三个塔上。</p>
<p>而对于四阶汉诺塔，我们要寻找一个合适的圆盘i，将其上的圆盘先移动到一个塔上，所需移动次数设为F[i]。然后再将其下的圆盘移动到最后一个塔上，此时就是三阶汉诺塔问题，D[n-i]。然后再将前i个圆盘移动到最后塔上，即F[i]。这个合适的圆盘i就是使得移动次数最少的圆盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> d[<span class="number">15</span>], f[<span class="number">15</span>];</span><br><span class="line">	d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">12</span>; i++)&#123;</span><br><span class="line">		d[i] = <span class="number">1</span> + d[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">			f[i] = min(f[i], f[j] * <span class="number">2</span> + d[i - j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">12</span>; i++) <span class="built_in">cout</span> &lt;&lt; f[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><blockquote>
<p>假设现在有两个自然数A和B，S是$A^B$的所有约数之和。<br>请你求出S mod 9901的值是多少。</p>
</blockquote>
<p>对于数A，我们可以将其分解成质数的形式，A=${p_{1}}^{k_{1}}{p_{2}}^{k_{2}}···{p_{n}}^{k_{n}}$，其中${p_{n}}$是A的质数约数，我们可以修改${k_{n}}$的大小来获得不同的约数，对于所有的约数之和我们可以表示为：<br>$({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}})\times ({p_{2}}^{0}+{p_{2}}^{1}+\cdot \cdot \cdot +{p_{2}}^{k_{2}})\times \cdot \cdot \cdot \times ({p_{n}}^{0}+{p_{n}}^{1}+\cdot \cdot \cdot +{p_{n}}^{k_{n}})$<br>对于每一部分，我们还可以进一步化简，例如，当$k_1$是奇数的时候，我们可以化简为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}}$<br>$= {p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2}+{p_{1}}^{k_{1}/2+1}\times ({p_{1}}^{0}+{p_{1}}^{1}+\cdot \cdot \cdot +{p_{1}}^{k_{1}/2})$<br>其中/代表着整数除法<br>如果$k_n$为偶数，那么就提出一个$p_n$即可，这样利用递归我们可以加速求解<br>而对于${p_{1}}^{k_{1}/2+1}$我们可以利用快速幂进行求解（参考上一博客位运算）。如下是代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">9901</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qmi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	a %= mod;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(k)&#123;</span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">		a = a * a % mod;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//如果k是偶数就提出一个P，则k-1变为奇数</span></span><br><span class="line">	<span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (p % mod * sum(p, k - <span class="number">1</span>) + <span class="number">1</span>) % mod;</span><br><span class="line">	<span class="comment">//如果k是奇数</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> + qmi(p, k/<span class="number">2</span> + <span class="number">1</span>)) * sum(p, k/<span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A, B;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=A; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(A % i ==<span class="number">0</span>)&#123;</span><br><span class="line">			s++;</span><br><span class="line">			A /= i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s) res = res * sum(i, s * B) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!A) res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分形之城"><a href="#分形之城" class="headerlink" title="分形之城"></a>分形之城</h4><blockquote>
<p>城市的规划在城市建设中是个大问题。<br>不幸的是，很多城市在开始建设的时候并没有很好的规划，城市规模扩大之后规划不合理的问题就开始显现。<br>而这座名为 Fractal 的城市设想了这样的一个规划方案，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200810085620117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="city.png">当城区规模扩大之后，Fractal 的解决方案是把和原来城区结构一样的区域按照图中的方式建设在城市周围，提升城市的等级。<br>对于任意等级的城市，我们把正方形街区从左上角开始按照道路标号。<br>虽然这个方案很烂，Fractal 规划部门的人员还是想知道，如果城市发展到了等级 N，编号为 A 和 B 的两个街区的直线距离是多少。<br>街区的距离指的是街区的中心点之间的距离，每个街区都是边长为 10 米的正方形。</p>
</blockquote>
<p>我们可以发现每一等级的城市都是由上一等级城市旋转平移得到的，所以对于该题，我们可以将n等级的城市进行递归，从1等级开始处理。<br>将城市划分成四个区域，左上、右上、左下、右下四个分区，根据所在分区决定上一等级城市该如何旋转平移。然后再将得到的当前等级城市下的坐标，传递给下一等级的城市，直至规定等级。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLL pair<span class="meta-string">&lt;ll,ll&gt;</span></span></span><br><span class="line"><span class="function">PLL <span class="title">calc</span><span class="params">(ll n,ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//边界结果</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//len代表当前等级下城市边长的一半（移动上一等级城市需要），cnt表示当前等级城市下街道数量的1/4（决定分区）</span></span><br><span class="line">    ll len=<span class="number">1L</span>L&lt;&lt;(n<span class="number">-1</span>),cnt=<span class="number">1L</span>L&lt;&lt;(<span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递归到最低级城市</span></span><br><span class="line">    PLL pos=calc(n<span class="number">-1</span>,m%cnt);</span><br><span class="line">    ll x=pos.first,y=pos.second;</span><br><span class="line">    <span class="comment">//z表示当前等级城市下，m序号的街道所处的分区，分为左上、右上、左下、右下四个分区，从而决定如何旋转</span></span><br><span class="line">    ll z=m/cnt;</span><br><span class="line">    <span class="comment">//根据分区位置旋转平移上一等级的街道，其中（x,y）代表上一等级城市下街道的位置</span></span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(y,x);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x,y+len);</span><br><span class="line">    <span class="keyword">if</span> (z==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> make_pair(x+len,y+len);</span><br><span class="line">    <span class="keyword">return</span> make_pair(<span class="number">2</span>*len<span class="number">-1</span>-y,len<span class="number">-1</span>-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n,a,b;</span><br><span class="line">        <span class="comment">//这里n代表当前城市等级，a、b代表两个街道的序号</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//简化边界处理，将序号从0开始</span></span><br><span class="line">        PLL x=calc(n,a<span class="number">-1</span>);</span><br><span class="line">        PLL y=calc(n,b<span class="number">-1</span>);</span><br><span class="line">        ll dx=x.first-y.first,dy=x.second-y.second;</span><br><span class="line">        <span class="keyword">double</span> ans=(<span class="built_in">sqrt</span>(dx*dx+dy*dy)*<span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.lf\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归改递推"><a href="#递归改递推" class="headerlink" title="递归改递推"></a>递归改递推</h4><p>用递推来实现递归代码，需要借助STL中的栈，计算机本身在处理递归代码的时候也是使用栈来实现的。</p>
<p>在这里我们通过“递归实现组合型枚举”来举例说明，我们首先要把原递归代码划分位置，用来标记处理过程。通过定义结构体，作为栈的保存对象，其中要包含标记位置。主函数中我们循环取出栈首元素，根据所标记的位置来决定如何处理当前元素，直至栈空。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> pos, u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> sum, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">	<span class="comment">//0</span></span><br><span class="line">	<span class="keyword">if</span>(sum + n _ u &lt; m) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(sum == m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">			<span class="keyword">if</span>(state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(u + <span class="number">1</span>, sum + <span class="number">1</span>, state | <span class="number">1</span> &lt;&lt; u);</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	dfs(u + <span class="number">1</span>, sum, state);</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.yop;</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.pos == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">					<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">						<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			t.pos = <span class="number">1</span>;</span><br><span class="line">			stk.push(t);</span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t.pos == <span class="number">1</span>)&#123;</span><br><span class="line">			t.pos = <span class="number">2</span>;<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(t);<span class="comment">//可去掉</span></span><br><span class="line">			stk.push(&#123;<span class="number">0</span>, t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//可去掉</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标记位置的方法只是个通用模板，我们可以将得到的递推继续优化如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u, sum, state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="comment">//dfs(0, 0, 0)</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;State&gt; stk;</span><br><span class="line">	stk.push(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(stk.size())&#123;</span><br><span class="line">		<span class="keyword">auto</span> t=stk.top();</span><br><span class="line">		stk.pop();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(t.sum + n - t.u &lt; m) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(t.sum == m)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">				<span class="keyword">if</span>(t.state &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        stk.push(&#123;t.u + <span class="number">1</span>, t.sum, t.state&#125;);</span><br><span class="line">		stk.push(&#123;t.u + <span class="number">1</span>, t.sum + <span class="number">1</span>, t.state | <span class="number">1</span> &lt;&lt; t.u&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2020/08/14/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><blockquote>
<p>地图上有 N 个目标，用整数Xi,Yi表示目标在地图上的位置，每个目标都有一个价值Wi。注意：不同目标可能在同一位置。<br>现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和x，y轴平行。<br>求一颗炸弹最多能炸掉地图上总价值为多少的目标。</p>
</blockquote>
<p>前缀和的定义就是对于当前数组，第i个数以前的数的总和，形成一个新的数组，即前缀和数组。$sum[i]=\sum_{j=0}^{i}num[i]$<br>以上是一维情况，对于二维数组，我们可以把它看成一个矩形，当前点的前缀和就是所在行以前和所在列以前所有数的总和$sum[i][j]=\sum_{m=0}^{i}\sum_{n=0}^{j}num[i][j]$<br>可以表示成下图的形式，对于黄色框内的前缀和，就是黄色=绿色+红色-蓝色。<br><img src="https://img-blog.csdnimg.cn/20200813092853480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对于这题，我们就可以用二维前缀和进行快速求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//M是二维数组最大范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5010</span>;</span><br><span class="line"><span class="comment">//记录二维数组每个点的价值, 初始化为0，记作全局变量，存储在堆空间，防止栈满。</span></span><br><span class="line"><span class="keyword">int</span> g[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//输入N行，每行输入一组数据，每组数据包括三个整数Xi,Yi,Wi,</span></span><br><span class="line">	<span class="comment">//R表示爆炸范围</span></span><br><span class="line">    <span class="keyword">int</span> N, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="comment">//n和m用来记录最大边界</span></span><br><span class="line">    <span class="keyword">int</span> n = R, m = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, x, y, w; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        <span class="comment">//处理边界，从1开始</span></span><br><span class="line">        x++, y++;</span><br><span class="line">        n=max(n,x), m=max(m,y);</span><br><span class="line">        g[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">            g[i][j] += g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>] - g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历前缀和，求解最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=R; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=R; j&lt;=m; j++)</span><br><span class="line">            res=max(res,g[i][j]-g[i-R][j]-g[i][j-R]+g[i-R][j-R]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以进一步简化代码，在计算前缀和的同时求解最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[M][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; R;</span><br><span class="line">    <span class="keyword">int</span> n = R, m = R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, x, y, w; i&lt;N; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        x++, y++;</span><br><span class="line">        n=max(n,x), m=max(m,y);</span><br><span class="line">        g[x][y] += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)&#123;</span><br><span class="line">            g[i][j] += g[i<span class="number">-1</span>][j] + g[i][j<span class="number">-1</span>] - g[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            x=max(i-R, <span class="number">0</span>);</span><br><span class="line">            y=max(j-R, <span class="number">0</span>);</span><br><span class="line">            res=max(res,g[i][j]-g[x][j]-g[i][y]+g[x][y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p>差分的定义就是，对于给定的数组$num$，第i个数和第i-1的差值所组成的新的数组就是差分数组，$dif[i]=num[i]-num[i-1]$（$dif[0]=num[0]$)。<br>对于差分数组和原数组存在如下关系<br>$num[i]=dif[0]+dif[1]+···+dif[i]<br>            =num[0]+num[1]-num[0]+···+num[i]-num[i-1]$</p>
<blockquote>
<p>给定一个长度为 n 的数列 a1,a2,…,an，每次可以选择一个区间 [l,r]，使下标在这个区间内的数都加一或者都减一。<br>求至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列可能有多少种。</p>
</blockquote>
<p>利用差分数组，对于某个区间（l, r）内加1，只需$b[l]+=1,b[r]-=1$，这样就可以在$O(1)$时间复杂度更改，而不用遍历（l，r）范围内的数组。<br>借用差分数组，我们只需将差分数组全部变为0，就可以使原数组的数全部相同。而对于可执行的操作，我们可以分成如下4类：</p>
<ol>
<li>1&lt;=i，j&lt;=n               该操作是针对i，j范围，必然伴随差分数组某两个数的加1以及减1</li>
<li>i=0, 1&lt;=j&lt;=n            该操作是针对j以前的所有数，只伴随着差分数组某个数的加1或者减1</li>
<li>1&lt;=i&lt;=n, j=n+1        该操作是针对i以后的所有数，同上</li>
<li>i=0, j=n+1                该操作是针对数组全部 差分数组不变</li>
</ol>
<p>对于第一种情况一次操作可以更改差分数组的两个数，是我们应该优先选择的，通过加减两个差分数组的数，可以使得数组中的正数和负数相抵消，最后再用第二种和第三种方法对剩余的正数或者负数进行清零。如此满足最少操作的要求。第四种操作没有意义。</p>
<p>我们需要知道一点，当差分数组正数之和和负数之和相等的时候，利用第一种方式对差分数组清零，无论操作顺序是什么样的，整个数组得到的结果都是一样的，都是和初始数组首末值相等的数组。因此我们可以得出，对于最终数组的可能情况仅仅取决于对剩余正数或者负数的操作。<br>而对于剩余数的操作只有第二种和第三种方式，两种方式的可能组合的方式数，就是最终解。直观一点来看，例如我们最终剩余正数是下图左边所示：<br><img src="https://img-blog.csdnimg.cn/20200813111323564.png#pic_center" alt="在这里插入图片描述"><br>黑线代表了差分数组还有两个正数差值，均是1，因此我们最终通过第2，3种方法，可以使原数组有红黄蓝三种方式使差分数组清零。最终代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="comment">//接受数组</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="comment">//生成差分数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n; i&gt;<span class="number">1</span>; i--) a[i]-=a[i<span class="number">-1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算差分数组正负数总和</span></span><br><span class="line">    LL pos=<span class="number">0</span>, neg=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;<span class="number">0</span>) pos+=a[i];</span><br><span class="line">        <span class="keyword">else</span> neg-=a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(pos, neg) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(pos-neg)+<span class="number">1</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有 N 头牛站成一行，被编队为1、2、3…N，每头牛的身高都为整数。<br>当且仅当两头牛中间的牛身高都比它们矮时，两头牛方可看到对方。<br>现在，我们只知道其中最高的牛是第 P 头，它的身高是 H ，剩余牛的身高未知。<br>但是，我们还知道这群牛之中存在着 M 对关系，每对关系都指明了某两头牛 A 和 B 可以相互看见。<br>求每头牛的身高的最大可能值是多少。</p>
</blockquote>
<p>这道题我们可以很明确的知道，数组首位的牛最高值就是H，因为给定的M对关系仅仅是数组内部的关系。所以根据于此，我们可以利用差分数组记录每对关系，在根据首位来确定原数组最理想的形式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> height[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n是牛的数量，p是第几头牛最高，h是最高的牛的高度，m是关系数。</span></span><br><span class="line">    <span class="keyword">int</span> n, p, h, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p &gt;&gt; h &gt;&gt; m;</span><br><span class="line">    height[<span class="number">1</span>]=h;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据关系，对差分数组的边界进行处理</span></span><br><span class="line">    <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; existed;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, a, b; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line">        <span class="keyword">if</span>(!existed.count(&#123;a, b&#125;))&#123;</span><br><span class="line">            existed.insert(&#123;a, b&#125;);</span><br><span class="line">            height[a+<span class="number">1</span>]--, height[b]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据差分数组，求解原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        height[i] += height[i<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; height[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS_Tutorials</title>
    <url>/2020/07/25/ROS-Tutorials/</url>
    <content><![CDATA[<p>本科时候图方便仅仅使用了Windows下的V-REP（想想用gazebo还要学Linux和ROS就好麻烦…)，最近由于需要学习了ROS，也算是填上本科时候埋下的坑(&gt;﹏&lt;)。</p>
<p>本文主要针对<a href="http://wiki.ros.org/cn" target="_blank" rel="noopener">ROS wiki教程</a>基于ROS Noetic踩得雷做一下总结，关于如何学习ROS，可以参考知乎高赞,马学长的回答<a href="https://zhuanlan.zhihu.com/p/26007106" target="_blank" rel="noopener">ROS学习入门（抛砖引玉篇）</a>。</p>
<h2 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h2><p>目前有在维护的版本有Kinetic、Melodic以及Noetic。由于我的Ubuntu版本是20.04，所以选择了Noetic，并且Noetic是最新版本，会维护到2025年。</p>
<p>在安装Ubuntu系统的时候切记主分区要大于15G，我最开始分了10G结果ROS安一半，它满了！！！弄得我又重装了一遍系统…</p>
<h2 id="节点、话题、服务"><a href="#节点、话题、服务" class="headerlink" title="节点、话题、服务"></a>节点、话题、服务</h2><p>这部分按照教程来做就可以了，注意Hydro版本和非Hydro版本的命令区别。</p>
<h2 id="创建ROS消息和服务"><a href="#创建ROS消息和服务" class="headerlink" title="创建ROS消息和服务"></a>创建ROS消息和服务</h2><p>在新增ROS消息和服务以后我们要对Catkin_package.txt进行修改，增加依赖，生成器，调用生成。</p>
<p>因为好多部分教程都要求找到注释代码，修改以后去掉注释，使代码生效。例如下面这样：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/%E6%8D%95%E8%8E%B7.PNG" alt=""></p>
<p>我又…是图方便，没有查找注释代码，直接将修改代码添加到尾部，当时觉得反正那部分也是注释无效的，结果又开启了找BUG之旅…</p>
<p>最后发现CMakeList.txt文件必须遵循如下的格式，不然就无法正确地编译：<br>1.查找编译依赖的其他CMake/Catkin包（声明依赖库）：find_package()<br>2.添加消息/服务/操作文件：add_message_files()…<br>3.调用消息/服务/操作生成：generate_messages()</p>
<h2 id="roswtf使用"><a href="#roswtf使用" class="headerlink" title="roswtf使用"></a>roswtf使用</h2><p>roswtf 可以检查你的ROS系统并尝试发现问题。</p>
<p>当我运行roswtf时发现系统报错,需要更新rosdep。<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-00-15%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>而当我按照提示运行命令rosdep update时又会发现：<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-01-04%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>卑微的我又按照提示安装了python3-rosdep2<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-20%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>本以为按照提示将缺少的软件包安装以后就万事大吉，结果当运行roscore的时候原本正常的ROS开始报错！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-03-30%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p>于是我就经历了卸ROS，安ROS，Google+Baidu无限的月读轮回当中╥﹏╥<br>最后偶然发现，在安装rosdep的过程当中，第一行提示正在卸载ros-noetic-desktop-full，what！！！？？？原来是rosdep在安装的过程中偷偷摸摸把我的ros-noetic卸载了，于是我在安装rosdep以后重装了一遍ros，这时候在运行roscore、roswtf就没问题啦！<br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-02-57%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-39%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""><br><img src="https://raw.githubusercontent.com/LeoWangUSTC/picture/master/ROS_Tutorials/2020-07-24%2011-05-59%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p>
]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="多级排序"><a href="#多级排序" class="headerlink" title="多级排序"></a>多级排序</h4><blockquote>
<p>莫斯科正在举办一个大型国际会议，有n个来自不同国家的科学家参会。<br>每个科学家都只懂得一种语言。<br>为了方便起见，我们把世界上的所有语言用1到109之间的整数编号。<br>在会议结束后，所有的科学家决定一起去看场电影放松一下。<br>他们去的电影院里一共有m部电影正在上映，每部电影的语音和字幕都采用不同的语言。<br>对于观影的科学家来说，如果能听懂电影的语音，他就会很开心；如果能看懂字幕，他就会比较开心；如果全都不懂，他就会不开心。<br>现在科学家们决定大家看同一场电影。<br>请你帮忙选择一部电影，可以让观影很开心的人最多。<br>如果有多部电影满足条件，则在这些电影中挑选观影比较开心的人最多的那一部。</p>
</blockquote>
<p>根据题意，我们可以先把科学家的语言统计成哈希表，再根据每个电影的语音和字幕统计听得懂和看得懂的人数，将每个电影保存成一个结构体，对这若干个结构体进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a和b记录电影听得懂和看得懂的人数，c记录电影的序号，最终我们要输出电影序号。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125; ans[<span class="number">200010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//m代表电影数，n代表科学家数量，index作为哈希表语言key。</span></span><br><span class="line"><span class="keyword">int</span> m, n, index;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; num, sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.a==b.a) <span class="keyword">return</span> a.b &gt; b.b;</span><br><span class="line">    <span class="keyword">return</span> a.a &gt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//统计科学家的语言，形成哈希表sum</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        sum[index]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录每部电影听得懂和看得懂的人数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        ans[i].a=sum[index];</span><br><span class="line">        ans[i].c=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index;</span><br><span class="line">        ans[i].b=sum[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对结构体进行排序</span></span><br><span class="line">    sort(ans, ans+m, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出排序后的首元素，+1是因为我们从0开始记录的，需要处理边界</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans[<span class="number">0</span>].c + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中位数问题"><a href="#中位数问题" class="headerlink" title="中位数问题"></a>中位数问题</h4><blockquote>
<p>在一条数轴上有 N 家商店，它们的坐标分别为 A1~AN。<br>现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。<br>为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。</p>
</blockquote>
<p>我们假设把货仓建在N家商店的中位数位置可以使得每家商店到货仓的距离之和最小，即货仓两侧的商店数量应一样多。如果不一样多，当货仓向中位数移动的时候，就会存在商店多的一侧距离之和减少，商店少的一侧距离之和增加，总体就会减小，因此可知，将货仓建在中位数是合理的。<br><img src="https://img-blog.csdnimg.cn/20200819121022697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//记录n家商店的位置，形成数组</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选取中位数，记录距离总和</span></span><br><span class="line">    <span class="keyword">int</span> mid = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(a[i]-a[mid]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态中位数：依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。</p>
</blockquote>
<p>该题我们可以维护两个堆，分别是大顶堆和小顶堆，其中大顶堆的堆顶就是我们当前的中位数，对于新输入的数，我们采取如下步骤</p>
<ol>
<li>加上新元素，当前序列总数是偶数，那么与大顶堆堆顶比较，<br>  (1)如果大于大顶堆堆顶，那么插入到小顶堆中<br>  (2)如果小于大顶堆堆顶，那么取出大顶堆堆顶放入到小顶堆中，将新元素放入大顶堆。</li>
<li>加上新元素，当前序列总数是奇数，那么与小顶堆堆顶比较，<br> (1)如果小于小顶堆堆顶，那么插入到大顶堆中<br> (2)如果大于小顶堆堆顶，那么取出小顶堆堆顶放入到大顶堆中，将新元素放入小顶堆中。      </li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//结果中位数数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="comment">//small小顶堆，big大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; small;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; big;</span><br><span class="line"> 	<span class="comment">//判断奇偶，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=num; j++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span>(j % <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!big.size() || m &lt; small.top()) big.push(m);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                big.push(small.top());</span><br><span class="line">                small.pop();</span><br><span class="line">                small.push(m);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(big.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt; big.top())&#123;</span><br><span class="line">                small.push(big.top());</span><br><span class="line">                big.pop();</span><br><span class="line">                big.push(m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> small.push(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//n表示输入组数，index是编号，num是序列长度</span></span><br><span class="line">    <span class="keyword">int</span> n, index, num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; index &gt;&gt; num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = solve(num);</span><br><span class="line">        <span class="comment">//输出编号，以及中位数个数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="string">" "</span> &lt;&lt; (num + <span class="number">1</span> &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//输出中位数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=res.size(); j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[j<span class="number">-1</span>] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(j % <span class="number">10</span>) || j==res.size()) <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="均分纸牌问题"><a href="#均分纸牌问题" class="headerlink" title="均分纸牌问题"></a>均分纸牌问题</h4><blockquote>
<p>n个人坐成一排，手里总共有m张牌，现在每次操作可以使得相邻两人之间传递一张牌，问至少需要多少次操作可以使得n个人手里的纸牌数相同。</p>
</blockquote>
<p>我们可以从边界开始考虑，如果当前排在第一位的人手里牌数a1少于m/n，那么他必将从第二个人手中抽取a1-m/n张牌，使得自己手里的牌数达到均值。这时，我们只需考虑a2~an需要多少次操作才能使所有人手里的纸牌数相同，因此该题可以转化为贪心问题。<br>注：若第一位人的手里牌数多于m/n，那么他必将多余的牌传递给第二个人才能达到要求。若在计算过程中某人手里的牌数是负数也没有关系，这说明他和之前所有人手里的牌数是不够均分到m/n的，在实际过程中，我们会先分给他足够的牌数，传递给之前的人。<br>所以这道题就变成里求解$Sum = \sum_{i=1}^{n}|S_{i}|$，其中$S_{i}=\sum_{j=1}^{i}(A_{j}-m/n)$，表示第i点需要和下一点传递的纸牌数</p>
<blockquote>
<p>现在我们将难度提升一下，若这n个人做成一圈，那么问至少需要多少次操作可以使得n个人手里的纸牌数相同。</p>
</blockquote>
<p>首先，给出一个结论，对于最少操作次数必然会有两人之间没有纸牌传递。<br>该结论的证明，我…不会…，以下给出个人简陋不严谨的思路。<br>对于该图我们可以简化成相邻两点，实线代表他们之间的传递，虚线代表其余点的传递流总和，蓝色代表纸牌走向。<br><img src="https://img-blog.csdnimg.cn/20200820093704920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因此我们可以将问题分成两种情况考虑，对于左边的情况，必然可以去掉一个相邻点之间的纸牌传递，使得纸牌传递不会存在循环流，减少传递次数。<br>而对于右边的情况，可以知道，右边红点手里的牌数是少于平均值的，那么我们可以让离其最近的一段连续区域（纸牌平均数多于总的平均数）来多给它传递，然后去掉离该点远的传递流，这样可以减少总的传递次数。（以后有更好的证明再来补……)</p>
<p>至此，我们可以将环形纸牌问题转化成普通纸牌问题，只需考虑在哪里将环形剪断，所得到的传递次数最少。我们假设，要在k和k+1之间将环剪断，那么，对于每个点所需的传递次数，表示如下：<br>$$k+1: S_{k+1}-S_{k}$$$$k+2: S_{k+2}-S_{k}$$</p>
<center> ~ </center>

<p>$$n: S_{n}-S_{k}$$$$1: S_{1}-S_{k}+S_{n}$$</p>
<center> ~ </center>

<p>$$k: S_{k}-S_{k}+S_{n}$$</p>
<p>其中$S_{i}$和均分纸牌相同，$S_{n}=0$，所以公式可以简化成求解使总和最小的k，即$argmin_{k}\sum S_{i}-S_{k}$。至此，我们就可以将问题转化为货仓选址问题，求出中位数，就是最优解，我们来看一个例题。</p>
<blockquote>
<p>七夕节因牛郎织女的传说而被扣上了「情人节」的帽子。<br>于是TYVJ今年举办了一次线下七夕祭。<br>Vani同学今年成功邀请到了cl同学陪他来共度七夕，于是他们决定去TYVJ七夕祭游玩。<br>TYVJ七夕祭和11区的夏祭的形式很像。<br>矩形的祭典会场由N排M列共计N×M个摊点组成。<br>虽然摊点种类繁多，不过cl只对其中的一部分摊点感兴趣，比如章鱼烧、苹果糖、棉花糖、射的屋……什么的。<br>Vani预先联系了七夕祭的负责人zhq，希望能够通过恰当地布置会场，使得各行中cl感兴趣的摊点数一样多，并且各列中cl感兴趣的摊点数也一样多。<br>不过zhq告诉Vani，摊点已经随意布置完毕了，如果想满足cl的要求，唯一的调整方式就是交换两个相邻的摊点。<br>两个摊点相邻，当且仅当他们处在同一行或者同一列的相邻位置上。<br>由于zhq率领的TYVJ开发小组成功地扭曲了空间，每一行或每一列的第一个位置和最后一个位置也算作相邻。<br>现在Vani想知道他的两个要求最多能满足多少个。<br>在此前提下，至少需要交换多少次摊点。</p>
</blockquote>
<p>因为只能横纵交换，所以列交换不会影响最终行内感兴趣的摊点数，我们可以把问题拆分成两个环形均分纸牌问题，分别求解行列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大横纵摊位数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> u=<span class="number">100010</span>; </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[u],c[u],f[u];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,t,i,j,x,y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a[u],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>; <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//形成S, 见均分纸牌公式</span></span><br><span class="line">        a[i]-=a[<span class="number">0</span>]/n;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对S排序，选取中位数，求出结果</span></span><br><span class="line">    sort(f+<span class="number">1</span>,f+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) ans+=<span class="built_in">abs</span>(f[i]-f[n+<span class="number">1</span>&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//n表示行数，m表示列数，t代表测试组数</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line">    <span class="comment">//对于每个感兴趣的摊位在行列处+1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        b[x]++,c[y]++; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//首位表示感兴趣摊位数总和</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) b[<span class="number">0</span>]+=b[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) c[<span class="number">0</span>]+=c[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断感兴趣摊位数是否可以均分到行、列</span></span><br><span class="line">    <span class="keyword">if</span>(b[<span class="number">0</span>]%n==<span class="number">0</span>&amp;&amp;c[<span class="number">0</span>]%m==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"both %lld\n"</span>,calc(b,n)+calc(c,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[<span class="number">0</span>]%n==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"row %lld\n"</span>,calc(b,n));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>]%m==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"column %lld\n"</span>,calc(c,m));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h4><blockquote>
<p>在这个问题中，您必须分析特定的排序算法—-超快速排序。<br>该算法通过交换两个相邻的序列元素来处理n个不同整数的序列，直到序列按升序排序。<br>对于输入序列9 1 0 5 4，超快速排序生成输出0 1 4 5 9。<br>您的任务是确定超快速排序需要执行多少交换操作才能对给定的输入序列进行排序。</p>
</blockquote>
<p>该问题就是需要计算序列中有多少对逆序对，我们要把所有逆序对全部交换，所以问题也可以改成冒泡排序需要多少次操作。<br>对于计算逆序对，常用的方法就是归并排序，朴素算法需要$O(n)$复杂度，而采用归并，可以降低为$O(nlogn)$。我们的关键就在于在归并的时候，采用双指针计算逆序对。如果前面指针所指的数要大于后面指针的数，这就说明前面序列的剩余元素都要大于后面指针所指元素，通过这种方式确定序列中的逆序对。用图来表示：<br><img src="https://img-blog.csdnimg.cn/20200820112350266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTY3NjkzMA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为逆序对数有可能多余10的10次幂，我们定义成long long类型</span></span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ll&gt;&amp; nums, ll l, ll r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    ll mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge(nums, l, mid);</span><br><span class="line">    merge(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//fp是前面指针，从l开始，bp是后面指针，从mid+1开始</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; temp;</span><br><span class="line">    ll fp = l, bp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bp &gt; r || fp &lt;= mid &amp;&amp; nums[fp] &lt; nums[bp]) temp.push_back(nums[fp++]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="comment">//如果nums[fp]&gt;nums[bp]，我们要统计一下前面指针剩余元素个数</span></span><br><span class="line">            res += mid + <span class="number">1</span> - min(mid + <span class="number">1</span>, fp);</span><br><span class="line">            temp.push_back(nums[bp++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=l; i&lt;=r; i++) nums[i] = temp[index++];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    ll num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; nums;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    	<span class="comment">//输入序列</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    merge(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//n表示序列长度，当n为0则结束输入</span></span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        solve(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>你一定玩过八数码游戏，它实际上是在一个3×3的网格中进行的,1个空格和1至8这8个数字恰好不重不漏地分布在这3×3的网格中。<br>例如：<br>5 2 8<br>1 3 _<br>4 6 7<br>在游戏过程中，可以把空格与其上、下、左、右四个方向之一的数字交换（如果存在）。<br>例如在上例中，空格可与左、上、下面的数字交换，分别变成：<br>左：<br>5 2 8<br>1 _ 3<br>4 6 7<br>上：<br>5 2 _<br>1 3 8<br>4 6 7<br>下：<br>5 2 8<br>1 3 7<br>4 6 _<br>奇数码游戏是它的一个扩展，在一个n×n的网格中进行，其中n为奇数，1个空格和1至$n^{2}−1$这$n^{2}−1$个数恰好不重不漏地分布在n×n的网格中。<br>空格移动的规则与八数码游戏相同，实际上，八数码就是一个n=3的奇数码游戏。<br>现在给定两个奇数码游戏的局面，请判断是否存在一种移动空格的方式，使得其中一个局面可以变化到另一个局面。</p>
</blockquote>
<p>对于二维数组我们通常将其转化成一维数组，如同环我们通常转化成链<br>可以发现，当”_“在同一行内移动的时候不会改变整个数组的逆序对个数。<br>而当”_“在列内交换的时候会改变整个数组的逆序对个数。而该题的n为奇数，可以得出列交换并不会改变数组中逆序对个数的奇偶性。<br>因此可以说逆序对个数奇偶性不同的奇数码不能相互转换。而对于奇偶性相同的奇数码则可以相互转换（怎么证明我也不知道，知道了再来补上吧……)。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//res记录逆序对个数，nums1记录第一个网格，nums2记录第二个网格，temp是临时数组</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> res;</span><br><span class="line"><span class="keyword">int</span> nums1[<span class="number">250010</span>], nums2[<span class="number">250010</span>], temp[<span class="number">250010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序 同上题</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    merge(nums, l, mid);</span><br><span class="line">    merge(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fp = l, bp = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fp &gt; mid || bp &lt;= r &amp;&amp; nums[fp] &gt; nums[bp])&#123;</span><br><span class="line">            res += mid + <span class="number">1</span> - fp;</span><br><span class="line">            temp[i] = nums[bp++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> temp[i] = nums[fp++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l; i&lt;=r; i++) nums[i]=temp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="comment">//输入数据0表示下划线，我们将输入数据保存成一维数组</span></span><br><span class="line">    <span class="keyword">int</span> num, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != n*n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(!num) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> nums1[i++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i != n*n<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(!num) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> nums2[i++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分别计算逆序对个数</span></span><br><span class="line">    merge(nums1, <span class="number">0</span>, n*n<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = res;</span><br><span class="line">    res=<span class="number">0</span>;</span><br><span class="line">    merge(nums2, <span class="number">0</span>, n*n<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//返回两个数组逆序对个数奇偶性是否相同</span></span><br><span class="line">    <span class="keyword">return</span> res%<span class="number">2</span> == ans%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(solve(n)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"TAK"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"NIE"</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>倍增算法</title>
    <url>/2020/09/02/%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>给定一个整数 M，对于任意一个整数集合 S，定义“校验值”如下:<br>从集合 S 中取出 M 对数(即 2∗M 个数，不能重复使用集合中的数，如果 S 中的整数不够 M 对，则取到不能取为止)，使得“每对数的差的平方”之和最大，这个最大值就称为集合 S 的“校验值”。<br>现在给定一个长度为 N 的数列 A 以及一个整数 T。<br>我们要把 A 分成若干段，使得每一段的“校验值”都不超过 T。<br>求最少需要分成几段。</p>
</blockquote>
<p>看见“使得平方之和最大”、“最少需要分成几段”就能发现该题是求解最大最小问题，最开始想到的就应该是二分查找，二分查找是解决最大最小问题最常用的办法。<br>对于差的平方之和最大，我们可以证明，将最大与最小做差的平方+次大次小做差的平方+···，此时的差的平方之和最大，可以用多项式展开来证明。并且M对数的数量是不定的，因此排序算法是不可避免的。<br>综上，我们应该用二分来确定每一段的长度，若分成n段则最坏时间复杂度在$O(n)$，每段又要调用$O(logn)$次二分，在每次二分又要用排序算法进行求解$O(nlogn)$。所以总的算法复杂度在$O(n^{2}log^{2}n)$，但经过严谨的数学证明应该是$O(n^{2}logn)$。</p>
<p>除了二分以外是否有更好的方法来减低时间复杂度，解决这个问题呢？那就是“倍增”，考虑如下问题</p>
<blockquote>
<p>对于给定一个正整数数列，已知其前缀和，如何快速求出从哪位元素开始，之前的所有元素总和大于sum。</p>
</blockquote>
<p>这题我们就可以用<a href="https://blog.csdn.net/weixin_41676930/article/details/107971905" target="_blank" rel="noopener">前缀和</a>的思想来解决，常规方法可能是用二分，但一定会耗费$logn$的时间。如果用朴素算法，则更需要$n$的时间。如果我们在朴素算法上进行改进，遍历前缀和的时候步长是动态变化的，而不是固定为1，遵循以下规则：</p>
<ol>
<li>end = 0，步长len初始化为1</li>
<li>如果此时end + l所指代的前缀和小于sum，那么我们就将l乘以2，扩大结尾end = end + l</li>
<li>如果此时end + l所指代的前缀和大于等于sum，那么我们就将l除以2</li>
<li>如果l == 0，那么此时就收敛到了结果</li>
</ol>
<p>相比于二分查找的好处就是，倍增在最差的情况下也才需要$O(logn)$的时间，而假如所求解越靠近队首，求解时间越短，平均时间复杂度要优于二分。</p>
<p>因此我们考虑用倍增来进一步优化求解，如果使用倍增，那么我们的时间复杂度可以降低为$O(nlog^{2}n)$，表示成如下图：<br><img src="https://img-blog.csdnimg.cn/2020082112474397.png#pic_center" alt="在这里插入图片描述"><br>如果最终结果要分成3段，长度分别是len1、len2和len3，那么在每一段，我们倍增查找用时就是$O(loglen1)$，排序用时就是$O(len1loglen1)$，因此每一段我们总用时就是$O(len1log^{2}len1)$。再将这若干段相加可以得到总的时间复杂度$O(nlog^{2}n)$，相比于二分要降低很多。</p>
<p>接下来，我们考虑进一步的优化。在上面的方法中，我们每倍增一段，就要重新计算整个区间的排序，可不可以利用归并排序的方法，当倍增一段，我们只计算倍增这一区间的排序，然后在利用之前的计算结果归并，这样的话就省去重复计算。<br>我们来看一下这样的时间复杂度，仍然以上图为例，假设最终结果分成3段，每一段排序的用时就是$O(len1loglen1)$，那么归并用时需要多久呢？我们知道每一段要进行$O(loglen1)$的时间，在这些时间里，我们要进行长度为1、2、4、8、······、2len1长度的归并排序，因此归并用时就是这些长度的累加和，利用等比数列求和可知结果是$O(len1)$的，所以每一段的用时就是$O(lenloglen + len)$，总用时就是各段用时相加，依旧是$O(nlogn + n)$。至此，我们明确了该题的最优解法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//n表示集合元素个数，t表示校验值，a、b、temp用来做排序运算，m是对数，res是结果</span></span><br><span class="line">ll n, t, a[N], b[N], temp[N];</span><br><span class="line"><span class="keyword">int</span> m, res;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">check</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> test)</span></span>&#123;</span><br><span class="line">	<span class="comment">//start表示当前要求解段的起始位置，end是当前小于校验值的结尾，test是要尝试的结尾</span></span><br><span class="line">	<span class="comment">//因为我们要对a数组进行排序，所以a数组end到test的顺序有可能之前已经被打乱，要拷贝b数组（原始数据）的内容</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=end + <span class="number">1</span>; i&lt;=test; i++) a[i] = b[i];</span><br><span class="line">    sort(a + end + <span class="number">1</span>, a + test + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//双指针归并</span></span><br><span class="line">    <span class="keyword">int</span> f = start, b = end+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//sum是最终这一段的校验值</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=test; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b &gt; test || f &lt;= end &amp;&amp; a[f]&lt;a[b]) temp[i] = a[f++];</span><br><span class="line">        <span class="keyword">else</span> temp[i] = a[b++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(test-start+<span class="number">1</span>&gt;&gt;<span class="number">1</span>) &amp;&amp; i&lt;m; i++)&#123;</span><br><span class="line">        sum += (temp[start+i]-temp[test-i]) * (temp[start+i]-temp[test-i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//start表示当前要求解段的起始位置，end是当前小于校验值的结尾，l是倍增长度</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, l;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; n)&#123;</span><br><span class="line">        l = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果倍增长度等于0，即收敛</span></span><br><span class="line">        <span class="keyword">while</span>(l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end + l &gt;= n || check(start, end, end + l) &gt; t) l &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="comment">// 当前end+l结尾可以满足条件，那么我们就将之前排好的序保存下来，方便下次使用</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start; i&lt;=end+l; i++) a[i]=temp[i];</span><br><span class="line">                end = end + l;</span><br><span class="line">                l &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始下一段的寻找</span></span><br><span class="line">        start = ++end;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//k表示测试集组数</span></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
